import extern "AK/Math.h" {
    extern fn min<T>(anon a: T, anon b: T) -> T
    extern fn max<T>(anon a: T, anon b: T) -> T
    extern fn log<T>(anon x: T) -> T
    extern fn exp<T>(anon x: T) -> T
    extern fn fabs<T requires(Floating)>(anon x: T) -> T
    extern fn sqrt<T requires(Floating)>(anon x: T) -> T
}

trait SetTheoric {
    fn union_(this, anon other: Self) -> Self
    fn intersection(this, anon other: Self) -> Self
    fn difference(this, anon other: Self) -> Self
    fn contains(this, anon element: Self) -> bool
}

type Array implements(SetTheoric) {
    [[inline()]]
    fn union_(this, anon other: Array<T>) -> Array<T> {
        mut result = this[..].to_array()
        result.push_values(&other)
        return result
    }
    [[inline()]]
    fn intersection(this, anon other: Array<T>) -> Array<T> {
        mut result: [T] = []
        for x in this {
            if other.contains(x) { result.push(x) }
        }
        return result
    }
    [[inline()]]
    fn difference(this, anon other: Array<T>) -> Array<T> {
        mut result: [T] = []
        for x in this {
            if not other.contains(x) { result.push(x) }
        }
        return result
    }
}

struct SensitivityId { id: u64 }
struct TypeId { id: u64 }
struct EpsilonId { id: u64 }

enum Epsilon {
    Fixed(f64)
    RuntimeVar(name: String)
    Min(a: EpsilonId, b: EpsilonId)
    Max(a: EpsilonId, b: EpsilonId)
}

struct Label implements(Equal<Label>, Hashable, FromStringLiteral) {
    name: String
    fn equals(this, anon other: Label) -> bool => .name == other.name
    fn hash(this) -> u32 => .name.hash()
    fn from_string_literal(anon s: StringView) -> Label {
        return Label(name: format("{}", s))
    }
}

class Fnv {
    public func: fn(anon epsilon: Epsilon) -> f64
    public fn call(this, anon epsilon: Epsilon) -> f64 {
        let f = &.func
        return f(epsilon)
    }
}

class LabelLattice {
    public tops: [Label]
    public bottoms: [Label]
    public hierarchy: [Label:[Label]]
    public epsilon_map: [Label:Epsilon]
    // from -> to -> (epsilon -> multiplier for result)
    public map: [Label:[Label:Fnv]]

    [[stores_arguments(map_direct:"return")]]
    public fn make(
        anon hierarchy: [Label:[Label]]
        anon epsilon_map: [Label:Epsilon]
        anon map_direct: &fn(from: Label, to: Label, epsilon: Epsilon) -> f64
    ) throws -> LabelLattice {
        mut tops: [Label] = []
        mut bottoms: [Label] = []
        mut map: [Label:[Label:Fnv]] = [:]
        for label in hierarchy.keys() {
            let dict: [Label:Fnv] = [:]
            map.set(label, dict)
        }

        for (label, lessers) in hierarchy {
            if lessers.size() == 0 {
                bottoms.push(label)
            }
            for lesser in lessers {
                map[lesser].set(label, Fnv(func: fn[&map_direct, lesser, label](anon epsilon: Epsilon) => map_direct(from: lesser, to: label, epsilon)))
            }
        }

        for (label, _) in hierarchy {
            // find top (no entry has this label as a lesser)
            if map.get(label)!.is_empty() {
                tops.push(label)
            }
        }

        return LabelLattice(tops: tops, bottoms: bottoms, hierarchy, epsilon_map, map)
    }

    public fn join(this, anon a: Label, anon b: Label) throws -> Label {
        let a_ancestors = .ancestors(a)
        if a_ancestors.contains(b) { return b }

        let b_ancestors = .ancestors(b)
        if b_ancestors.contains(a) { return a }

        return fold(a_ancestors.intersection(b_ancestors),
            &fn[this](anon acc: Label, anon x: &Label) throws -> Label => match .hierarchy[acc].contains(*x) { true => *x, false => acc }
        )
    }

    public fn ancestors(this, anon label: Label) -> [Label] {
        mut open: [Label] = [label]
        mut closed: [Label] = []
        while open.size() > 0 {
            let current = open.pop()!
            closed.push(current)
            for parent in .hierarchy[current] {
                if not closed.contains(parent) and not open.contains(parent) {
                    open.push(parent)
                }
            }
        }
        return closed[1..].to_array()
    }

    public fn best_path_for(
        this
        from: Label
        to: Label
        epsilon: Epsilon
    ) throws -> ([Label], f64)? {
        mut open: [Label] = [from]
        mut closed: [Label] = []
        mut costs: [Label:f64] = [from: 0f64]
        mut parents: [Label:Label] = [:]

        if .ancestors(from).contains(to) {
            return ([from, to], 0.0f64)
        }

        while open.size() > 0 {
            let current = fold(open,
                &fn[this, &costs](anon acc: Label, anon x: &Label) throws -> Label => match costs[x] < costs[acc] { true => *x, false => acc }
            )
            if current == to {
                mut result: [Label] = [to]
                while not result[0].equals(from) {
                    result.insert(before_index: 0, value: parents[result[0]])
                }
                return (result, costs[to])
            }

            open = open.difference([current])
            closed.push(current)

            for next in .map[current].keys() {
                if closed.contains(next) { continue }
                let cost = costs[current] + .map[current][next].call(epsilon) // Assume epsilon = 1 for now
                if not open.contains(next) or cost < costs[next] {
                    costs.set(next, cost)
                    parents.set(next, current)
                    if not open.contains(next) { open.push(next) }
                }
            }
        }

        // No direct path, try to find a path through a common ancestor
        let common_ancestor = .join(from, to)
        eprintln("No direct path from {} to {}, trying through {}", from, to, common_ancestor)
        guard .best_path_for(from, to: common_ancestor, epsilon) is Some(fpc)
            and .best_path_for(from: common_ancestor, to, epsilon) is Some(cpt)
            else { return None }
        
        eprintln("Found common ancestor path: {} -> {} -> {}", from, common_ancestor, to)

        let (from_path, from_cost) = fpc
        let (common_path, common_cost) = cpt
        return (from_path.union_(common_path), from_cost + common_cost)
    }

    fn tree(this, anon label: Label, anon builder: &mut StringBuilder, anon indent: usize = 0) throws {
        builder.appendff("{: >{}}{}\n", "", indent, label)
        for lesser in .hierarchy[label] {
            .tree(lesser, builder, indent: indent + 2)
        }
    }

    public fn render(this) throws -> String {
        mut builder = StringBuilder::create()
        builder.append("Lattice:\n")
        for top in this.tops {
            .tree(top, &mut builder)
        }
        builder.append("Epsilon map:\n")
        for (label, epsilon) in this.epsilon_map {
            builder.appendff("  {}: {}\n", label, epsilon)
        }
        return builder.to_string()
    }
}

type SensitivityId implements(Hashable, Equal<SensitivityId>) {
    fn hash(this) -> u32 => .id.hash()
    fn equals(this, anon other: SensitivityId) -> bool => .id == other.id
}
type TypeId implements(Hashable, Equal<TypeId>) {
    fn hash(this) -> u32 => .id.hash()
    fn equals(this, anon other: TypeId) -> bool => .id == other.id
}
type EpsilonId implements(Hashable, Equal<EpsilonId>) {
    fn hash(this) -> u32 => .id.hash()
    fn equals(this, anon other: EpsilonId) -> bool => .id == other.id
}

trait Map<T> { fn map<U>(this, anon f: &fn(anon x: &T) throws -> U) throws -> [U] }
type Array implements(Map<T>) {
    [[inline()]]
    fn map<U>(this, anon f: &fn(anon x: &T) throws -> U) throws -> [U] {
        mut result: [U] = []
        result.ensure_capacity(.size())
        for x in this {
            result.push(f(&x))
        }
        return result
    }
}

fn fold<T>(
    anon list: [T]
    anon f: &fn(anon acc: T, anon x: &T) throws -> T
) throws -> T {
    mut acc = list[0]
    for x in list[1..] {
        acc = f(acc, &x)
    }
    return acc
}

fn unchecked() -> TypeId => TypeId(id: 0)

class SensitivityMapped<T> {
    public value: T
    public sensitivity: SensitivityId?
    public sensitivity_multiplier: f64 = 1f64
}

enum InferredRange<T> {
    Unknown
    Bounded(from: T, to: T)
}

boxed enum Type {
    Unchecked
    Int(InferredRange<i64>)
    Bool(InferredRange<bool>)
    List(type: TypeId, size: usize)
    Pair(left: TypeId, right: TypeId)
    TypeWithSec(type: TypeId, label: Label, epsilon: EpsilonId)

    fn element_type(this, type_map: &mut [TypeId:Type]) -> TypeId => match this {
        List(type) => type
        TypeWithSec(type, label, epsilon) => make_type(type_map, Type::TypeWithSec(type, label, epsilon))
        else => {
            eprintln("Invalid element type request for {}", this)
            abort()
        }
    }

    fn element_count(this, type_map: &[TypeId:Type]) -> usize => match this {
        List(size) => size
        Pair => 2
        TypeWithSec(type) => type_map[type].element_count(type_map)
        else => 1
    }

    fn label(this, lattice: &LabelLattice) -> Label => match this {
        TypeWithSec(label) => label
        else => lattice.bottoms[0]
    }

    fn render(this, anon type_map: &[TypeId: Type]) throws -> String => match this {
        Unchecked => "unchecked"
        Int(range) => match range {
            Unknown => "int"
            Bounded(from: from, to: to) => format("int({}..{})", from, to)
        }
        Bool(range) => match range {
            Unknown => "bool"
            Bounded(from: from, to: to) => format("bool({}..{})", from, to)
        }
        List(type, size) => format("list {} {}", type_map[type].render(type_map), size)
        Pair(left, right) => format("{} Ã— {}", type_map[left].render(type_map), type_map[right].render(type_map))
        TypeWithSec(type: type_id, label: label, epsilon: epsilon) => {
            let inner = type_map[type_id].render(type_map)
            return format("{} lab({}) eps(e{})", inner, label.name, epsilon.id)
        }
    }
}

enum Operation {
    Add, Sub, Mul, Div, Pair
}

boxed enum Expression {
    type: SensitivityMapped<TypeId> = SensitivityMapped(value: unchecked(), sensitivity: None)

    IntLiteral(value: i64)
    Variable(name: String)
    Noise(expr: Expression, epsilon: EpsilonId)
    Declassify(expr: Expression, source_epsilon: EpsilonId, target_label: Label, target_epsilon: EpsilonId)
    Subscript(expr: Expression, index: Expression)
    Operation(op: Operation, operands: Array<Expression>)

    fn with_type(this, anon type: TypeId, sensitivity: SensitivityId? = None, sensitivity_multiplier: f64 = 1.0) -> Expression {
        mut sens = SensitivityMapped(value: .type.value, sensitivity: .type.sensitivity)
        if .type.value == unchecked() {
            sens.value = type
            if sensitivity is Some(value) {
                sens.sensitivity = value
                sens.sensitivity_multiplier = sensitivity_multiplier
            }
        }

        return match this {
            IntLiteral(value) => Expression::IntLiteral(type: sens, value)
            Variable(name) => Expression::Variable(type: sens, name)
            Noise(expr, epsilon) => Expression::Noise(type: sens, expr, epsilon)
            Declassify(expr, source_epsilon, target_label, target_epsilon) => Expression::Declassify(type: sens, expr, source_epsilon, target_label, target_epsilon)
            Subscript(expr, index) => Expression::Subscript(type: sens, expr, index)
            Operation(op, operands) => Expression::Operation(type: sens, op, operands)
        }
    }

    fn add_sensitivity(mut this, sensitivity_context: &mut Context<SensitivityId, f64>) -> Expression {
        mut sens = SensitivityMapped(value: .type.value, sensitivity: .type.sensitivity)
        if .type.sensitivity is None {
            let id = SensitivityId(id: sensitivity_context.map.size() as! u64)
            sensitivity_context.map.set(id, 1f64)
            sens.sensitivity = id
            match this { else(&mut type) => { type.sensitivity = id } }
        } else {
            let id = .type.sensitivity!
            let value = sensitivity_context.lookup(id)
            sensitivity_context.map.set(id, value + 1f64)
        }

        return match this {
            IntLiteral(value) => Expression::IntLiteral(type: sens, value)
            Variable(name) => Expression::Variable(type: sens, name)
            Noise(expr, epsilon) => Expression::Noise(type: sens, expr, epsilon)
            Declassify(expr, source_epsilon, target_label, target_epsilon) => Expression::Declassify(type: sens, expr, source_epsilon, target_label, target_epsilon)
            Subscript(expr, index) => Expression::Subscript(type: sens, expr, index)
            Operation(op, operands) => Expression::Operation(type: sens, op, operands)
        }
    }

    fn to_tree(this, type_map: &[TypeId:Type], indent: usize = 0) throws -> String => match this {
        IntLiteral(
            value: x
        ) => format(
            "{: >{}}int({}) type={} sens=s{}*{}"
            ""
            indent
            x
            type_map[.type.value].render(type_map)
            .type.sensitivity?.id
            .type.sensitivity_multiplier
        )
        Variable(
            name: x
        ) => format(
            "{: >{}}var({}) type={} sens=s{}*{}"
            ""
            indent
            x
            type_map[.type.value].render(type_map)
            .type.sensitivity?.id
            .type.sensitivity_multiplier
        )
        Noise(expr, epsilon) => {
            abort()
        }
        Declassify(expr, source_epsilon, target_label, target_epsilon) => format(
            "{: >{}}declassify(to={}, eps={}) type={} sens=s{}*{}\n{}"
            ""
            indent
            target_label.name
            target_epsilon.id
            type_map[.type.value].render(type_map)
            .type.sensitivity?.id
            .type.sensitivity_multiplier
            expr.to_tree(type_map, indent: indent + 2)
        )
        Subscript(
            expr
            index
        ) => format(
            "{: >{}}sub({}) {} type={} sens=s{}*{}"
            ""
            indent
            index.to_tree(type_map, indent: 0)
            expr.to_tree(type_map, indent: 0)
            type_map[.type.value].render(type_map)
            .type.sensitivity?.id
            .type.sensitivity_multiplier
        )
        Operation(op, operands) => {
            mut x = format(
                "{: >{}}op({}) type={} sens=s{}*{}"
                ""
                indent
                op
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            )
            for operand in operands {
                x += "\n" + operand.to_tree(type_map, indent: indent + 2)
            }
            yield x
        }
    }
}

boxed enum Statement {
    type: SensitivityMapped<TypeId> = SensitivityMapped(value: unchecked(), sensitivity: None)

    Expression(Expression)
    ForEach(var: String, index: String, list: Expression, body: Statement)
    Return(Expression)
    IfThenElse(condition: Expression, consequence: Statement, alternative: Statement)
    Assign(var: String, value: Expression)
    Sequence(first: Statement, second: Statement)

    fn with_type(this, anon type: TypeId, sensitivity: SensitivityId? = None, sensitivity_multiplier: f64 = 1.0) -> Statement {
        mut sens = SensitivityMapped(value: .type.value, sensitivity: .type.sensitivity)
        if .type.value == unchecked() {
            sens.value = type
            if sensitivity is Some(value) {
                sens.sensitivity = value
                sens.sensitivity_multiplier = sensitivity_multiplier
            }
        }

        return match this {
            Expression(expr) => Statement::Expression(type: sens, expr)
            ForEach(var, index, list, body) => Statement::ForEach(type: sens, var, index, list, body)
            Return(expr) => Statement::Return(type: sens, expr)
            IfThenElse(condition, consequence, alternative) => Statement::IfThenElse(type: sens, condition, consequence, alternative)
            Assign(var, value) => Statement::Assign(type: sens, var, value)
            Sequence(first, second) => Statement::Sequence(type: sens, first, second)
        }
    }

    fn to_tree(this, type_map: &[TypeId: Type], indent: usize = 0) throws -> String => match this {
        Expression(expr) => expr.to_tree(type_map, indent: indent)
        ForEach(var, index, list, body) =>
            format(
                "{: >{}}for {} in [{}] type={} sens=s{}*{}\n"
                ""
                indent
                var
                list.to_tree(type_map, indent)
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            ) + body.to_tree(type_map, indent: indent + 2)
        Return(expr) =>
            format(
                "{: >{}}return type={} sens=s{}*{}"
                ""
                indent
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            ) + expr.to_tree(type_map, indent: indent + 2)
        IfThenElse(condition, consequence, alternative) =>
            format(
                "{: >{}}if type={} sens=s{}*{} then\n"
                ""
                indent
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            ) + consequence.to_tree(type_map, indent: indent + 2) + "\nelse\n" + alternative.to_tree(type_map, indent: indent + 2)
        Assign(var, value) =>
            format(
                "{: >{}}{} = {} type={} sens=s{}*{}"
                ""
                indent
                var
                value.to_tree(type_map, indent)
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            )
        Sequence(first, second) =>
            first.to_tree(type_map, indent: indent) + " ; " + second.to_tree(type_map, indent: indent)
    }
}

struct Procedure {
    name: String
    parameters: [String:SensitivityMapped<TypeId>]
    return_type: TypeId
    body: Statement
}

class Context<K requires(Hashable), V> {
    public map: [K:V]
    public base: Context<K, V>? = None

    public fn lookup(this, anon key: K) -> V {
        if not .map.contains(key) {
            if .base is Some(base) { return base.lookup(key) }
            eprintln("Key not found: '{}'", key)
            eprintln("  in context: {}", this)
            abort()
        }
        return .map[key]
    }
    public fn find(this, anon key: K) -> V? {
        if .map.contains(key) { return .map[key] }
        if .base is Some(base) { return base.find(key) }
        return None
    }

    public fn insert(mut this, anon key: K, anon value: V) throws { .map.set(key, value) }

    public fn dump(this) {
        for (key, value) in .map {
            eprintln("  {}: {}", key, value)
        }
        if .base is Some(base) { base.dump() }
    }
}

fn child_context<K requires(Hashable), V>(anon parent: Context<K, V>) -> Context<K, V> {
    return Context(map: [:], base: Some(parent))
}

fn make_type(
    type_map: &mut [TypeId:Type]
    anon type: Type
) -> TypeId {
    let id = TypeId(id: type_map.size() as! u64)
    type_map.set(id, type)
    return id
}

fn merge_bounds(
    type_map: &mut [TypeId: Type]
    epsilon_context: &mut Context<EpsilonId, Epsilon>
    anon type1: Type
    anon type2: Type
    op: Operation
) throws -> Type {
    if type2 is TypeWithSec and not type1 is TypeWithSec { return merge_bounds(type_map, epsilon_context, type2, type1, op) }
    return match type1 {
        Unchecked => type2
        Int(range1) => match type2 {
            Int(range2) => Type::Int(match range1 {
                Unknown => range1
                Bounded(from: from1, to: to1) => match range2 {
                    Unknown => range2
                    Bounded(from: from2, to: to2) => match op {
                        Add => InferredRange::Bounded(from: from1 + from2, to: to1 + to2)
                        Sub => InferredRange::Bounded(from: from1 - to2, to: to1 - from2)
                        Mul => InferredRange::Bounded(
                            from: min(min(from1 * from2, from1 * to2), min(to1 * from2, to1 * to2))
                            to: max(max(from1 * from2, from1 * to2), max(to1 * from2, to1 * to2))
                        )
                        Div => match from2 == 0 or to2 == 0 {
                            true => InferredRange::Unknown
                            false => InferredRange::Bounded(from: min(min(from1 / from2, from1 / to2), min(to1 / from2, to1 / to2)) to: max(max(from1 / from2, from1 / to2), max(to1 / from2, to1 / to2)))
                        }
                        Pair => {
                            eprintln("Invalid operation for int: Pair")
                            abort()
                        }
                    }
                }
            })
            else => {
                eprintln("Type mismatch between {} and {}", type1, type2)
                return type1
            }
        }
        Bool(range1) => match type2 {
            Bool(range2) => Type::Bool(match range1 {
                Unknown => range1
                Bounded(from: from1, to: to1) => match range2 {
                    Unknown => range2
                    Bounded(from: from2, to: to2) => match op {
                        // Add: OR, Mul: AND, Sub: AND NOT, Div: AND NOT; TODO: Split into actual bool operations.
                        Add => InferredRange::Bounded(from: from1 or from2, to: to1 or to2)
                        Mul => InferredRange::Bounded(from: from1 and from2, to: to1 and to2)
                        Sub => InferredRange::Bounded(from: from1 and not to2, to: to1 and not from2)
                        Div => InferredRange::Bounded(from: from1 and not to2, to: to1 and not from2)
                        Pair => {
                            eprintln("Invalid operation for int: Pair")
                            abort()
                        }
                    }
                }
            })
            else => {
                eprintln("Type mismatch between {} and {}", type1, type2)
                return type1
            }
        }
        Pair(left, right) => {
            let left_type = type_map[left]
            let right_type = type_map[right]
            let new_left = merge_bounds(type_map, epsilon_context, left_type, type2, op)
            let new_right = merge_bounds(type_map, epsilon_context, right_type, type2, op)
            yield Type::Pair(left: make_type(type_map, new_left), right: make_type(type_map, new_right))
        }
        List => {
            eprintln("TODO: Implement list type merging")
            return type1
        }
        TypeWithSec(type: ty1, label: label1, epsilon: epsilon1) => match type2 {
            TypeWithSec(type: ty2, label: label2, epsilon: epsilon2) => {
                if label1 != label2 {
                    eprintln("Label mismatch between {} and {}", type1.render(&type_map), type2.render(&type_map))
                    return type2
                }
                let inner = merge_bounds(type_map, epsilon_context, type_map[ty1], type_map[ty2], op)
                let epsilon = EpsilonId(id: epsilon_context.map.size() as! u64)
                epsilon_context.insert(epsilon, Epsilon::Max(a: epsilon1, b: epsilon2))
                yield Type::TypeWithSec(type: make_type(type_map, inner), label: label1, epsilon)
            }
            else => {
                let inner = merge_bounds(type_map, epsilon_context, type_map[ty1], type2, op)
                yield Type::TypeWithSec(type: make_type(type_map, inner), label: label1, epsilon: epsilon1)
            }
        }
    }
}

fn smooth(anon existing: f64, anon local: f64, beta: f64) -> f64 {
    let result = existing * exp(-beta * local)
    print("Smoothed {} with {} and {} to {}\n", existing, local, beta, result)
    return result
}

fn max_difference_for(anon x: &Type, anon type_map: &[TypeId: Type]) -> f64? => match x {
    Int(range) => match range {
        Unknown => None // TODO: Implement infinite sensitivity
        Bounded(from, to) => fabs(to as! f64 - from as! f64)
    }
    Bool => 1f64
    List(type) | TypeWithSec(type) => max_difference_for(&type_map[type], type_map)
    Pair(left, right) => {
        if max_difference_for(&type_map[left], type_map) is Some(left_diff)
            and max_difference_for(&type_map[right], type_map) is Some(right_diff) {
            return max(left_diff, right_diff)
        }
        return None
    }
    else => None
}

fn sens_merge(
    anon sens1: SensitivityId?
    anon sens2: SensitivityId?
    op: Operation
    local_sensitivity: f64
    sensitivity_context: &mut Context<SensitivityId, f64>
    type_map: &mut [TypeId: Type]
    anon lhs: Type
    anon rhs: Type
) -> SensitivityId? {
    if sens1 is None { return sens2 }
    if sens2 is None { return None }

    let s1 = sens1!
    let s2 = sens2!

    let value1 = sensitivity_context.lookup(s1)
    let value2 = sensitivity_context.lookup(s2)

    guard max_difference_for(&lhs, &type_map) is Some(lhs_max_diff)
        and max_difference_for(&rhs, &type_map) is Some(rhs_max_diff)
        else { return None }
    let result = match op {
        Add | Sub => value1 + value2 + local_sensitivity
        Mul | Div => value1 * rhs_max_diff + value2 * lhs_max_diff + local_sensitivity
        Pair => 1f64
    }

    let id = SensitivityId(id: sensitivity_context.map.size() as! u64)
    sensitivity_context.map.set(id, result)
    return id
}

fn typecheck(
    lattice: &LabelLattice
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, Epsilon>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon mut expr: Expression
) throws -> Expression => match expr {
    IntLiteral(value) => expr.with_type(make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: value, to: value))))
    Variable(name) => {
        let type = type_context.lookup(name)
        yield expr.with_type(
            type
            sensitivity: type_level_sensitivity_context.find(type)
        ).add_sensitivity(sensitivity_context)
    }
    Subscript(expr, index) => {
        let checked_expr = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, expr)
        let checked_index = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, index)
        mut expr_type = type_map[checked_expr.type.value]
        let unchecked_expr = Expression::Subscript(expr: checked_expr, index: checked_index)
        mut wrap_with_sec = fn(anon type: TypeId) throws => type

        if expr_type is TypeWithSec(type, label, epsilon) {
            wrap_with_sec = fn[
                &mut type_map
                label
                epsilon
            ](anon type: TypeId) throws -> TypeId => make_type(type_map, Type::TypeWithSec(type, label, epsilon))
            expr_type = type_map[type]
        }

        mut result = match expr_type {
            List(type, size) => unchecked_expr.with_type(wrap_with_sec(type))
            Pair(left, right) => match checked_index {
                IntLiteral(value) => match value {
                    0 => unchecked_expr.with_type(wrap_with_sec(left))
                    1 => unchecked_expr.with_type(wrap_with_sec(right))
                    else => {
                        eprintln("Invalid index for pair: {}", value)
                        abort()
                    }
                }
                else => {
                    eprintln("Invalid index type for pair: {}", checked_index)
                    abort()
                }
            }
            else => {
                eprintln("Invalid subscript type: {}", expr_type)
                abort()
            }
        }

        yield result.add_sensitivity(sensitivity_context)
    }
    Declassify(expr, source_epsilon, target_label, target_epsilon) => {
        let checked_expr = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, expr)
        let label = target_label
        guard lattice.best_path_for(
            from: type_map[checked_expr.type.value].label(lattice)
            to: label
            epsilon: epsilon_context.lookup(target_epsilon)
        ) is Some(pc) else {
            eprintln("Going from {} to {} is either not a declassify, or is not possible", type_map[checked_expr.type.value].label(lattice), label)
            return checked_expr
        }

        let (path, cost) = pc

        println("Path from {} to {}: {} (cost = {})", type_map[checked_expr.type.value].label(lattice), label, path, cost)
        let type = make_type(type_map, Type::TypeWithSec(type: checked_expr.type.value, label, epsilon: target_epsilon))
        yield Expression::Declassify(expr: checked_expr, source_epsilon, target_label: label, target_epsilon).with_type(
            type
            sensitivity: checked_expr.type.sensitivity
            sensitivity_multiplier: checked_expr.type.sensitivity_multiplier
        )
    }
    Operation(op, operands) => {
        let checked_operands = operands.map(
            &fn[
                &lattice
                &mut type_map
                &mut type_context
                &mut type_level_sensitivity_context
                &mut epsilon_context
                &mut sensitivity_context
            ](anon x: &Expression) throws -> (Expression, Context<SensitivityId, f64>) {
                mut new_sensitivity_context = child_context(*sensitivity_context)
                let result = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context: &mut new_sensitivity_context, *x)
                return (result, new_sensitivity_context)
            }
        )
        let type = fold(
            checked_operands.map(
                &fn(
                    anon x: &(Expression, Context<SensitivityId, f64>)
                ) throws -> (SensitivityMapped<TypeId>, Context<SensitivityId, f64>) => (x.0.type, x.1)
            ),
            &fn[
                &mut type_map
                &mut type_context
                &mut epsilon_context
                &mut sensitivity_context
                op
            ](
                anon acc: (SensitivityMapped<TypeId>, Context<SensitivityId, f64>)
                anon x: &(SensitivityMapped<TypeId>, Context<SensitivityId, f64>)
            ) throws -> (SensitivityMapped<TypeId>, Context<SensitivityId, f64>) {
                let acc_type = type_map[acc.0.value]
                let x_type = type_map[x.0.value]
                // FIXME: Implement type unification + sensitivity merging
                let local_sensitivity = match x.0.sensitivity.has_value() {
                    true => x.1.lookup(x.0.sensitivity!)
                    false => 0f64
                }
                let sensitivity = sens_merge(
                    acc.0.sensitivity
                    x.0.sensitivity
                    op
                    local_sensitivity
                    &mut sensitivity_context
                    &mut type_map
                    acc_type
                    x_type
                )
                let sens = SensitivityMapped(
                    value: make_type(type_map, merge_bounds(type_map, epsilon_context, acc_type, x_type, op))
                    sensitivity
                )
                return (sens, acc.1)
            }
        ).0

        let operands = checked_operands.map(&fn(anon x: &(Expression, Context<SensitivityId, f64>)) throws => x.0)

        yield Expression::Operation(type, op, operands)
    }
    else => {
        eprintln("Typecheck not implemented for {}", expr)
        abort()
    }
}

fn typecheck(
    lattice: &LabelLattice
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, Epsilon>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon mut stmt: Statement
) throws -> Statement => match stmt {
    Expression(
        expr
    ) => {
        let checked = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, expr)
        yield Statement::Expression(type: checked.type, checked)
    }
    ForEach(var, index, list, body) => {
        let list_expr = typecheck(
            lattice
            type_map
            type_context
            type_level_sensitivity_context
            epsilon_context
            sensitivity_context
            list
        )
        let list_type = type_map.get(list_expr.type.value)!
        let list_sens = type_level_sensitivity_context.find(list_expr.type.value)
        let entry_var_type = list_type.element_type(&mut type_map)
        mut new_type_context = child_context(*type_context)
        new_type_context.insert(var, entry_var_type)
        let entry_var_sens = SensitivityId(id: sensitivity_context.map.size() as! u64)
        sensitivity_context.insert(entry_var_sens, 1f64)
        type_level_sensitivity_context.insert(entry_var_type, entry_var_sens)
        let index_var_type = make_type(
            &mut type_map
            Type::Int(InferredRange::Bounded(from: 0i64, to: list_type.element_count(&type_map) as! i64 - 1i64))
        )
        new_type_context.insert(index, index_var_type)
        let index_var_sens = SensitivityId(id: sensitivity_context.map.size() as! u64)
        sensitivity_context.insert(index_var_sens, 1f64)
        type_level_sensitivity_context.insert(index_var_type, index_var_sens)

        if sens_merge(
                list_sens
                entry_var_sens
                op: Operation::Add
                local_sensitivity: 0f64
                sensitivity_context
                type_map
                list_type
                type_map.get(entry_var_type)!
            ) is Some(new_sens) {
            type_level_sensitivity_context.insert(entry_var_type, new_sens)
            sensitivity_context.insert(new_sens, 1f64)
        }

        let body_stmt = typecheck(
            lattice
            type_map
            type_context: &mut new_type_context
            type_level_sensitivity_context
            epsilon_context
            sensitivity_context
            body
        )
        let body_sens = body_stmt.type.sensitivity
        mut loop_sensitivity = body_stmt.type.sensitivity
        mut loop_sensitivity_multiplier = 1f64

        if sens_merge(
            list_sens
            body_sens
            op: Operation::Add
            local_sensitivity: 0f64
            sensitivity_context
            type_map
            type_map.get(list_expr.type.value)!
            type_map.get(body_stmt.type.value)!
        ) is Some(new_sens) {
            type_level_sensitivity_context.insert(body_stmt.type.value, new_sens)
            let total_sensitivity_multiplier = list_type.element_count(&type_map)
            loop_sensitivity = new_sens
            loop_sensitivity_multiplier = total_sensitivity_multiplier as! f64
        }

        yield Statement::ForEach(var, index, list: list_expr, body: body_stmt).with_type(
            type: body_stmt.type.value
            sensitivity: loop_sensitivity
            sensitivity_multiplier: loop_sensitivity_multiplier
        )
    }
    else => {
        eprintln("Typecheck not implemented for ", stmt)
        abort()
    }
}

fn main() {
    mut type_map: [TypeId:Type] = [unchecked(): Type::Unchecked]
    mut type_context: Context<String, TypeId> = Context(map: [:])
    mut type_level_sensitivity_context: Context<TypeId, SensitivityId> = Context(map: [:])
    mut epsilon_context: Context<EpsilonId, Epsilon> = Context(map: [:])
    mut sensitivity_context: Context<SensitivityId, f64> = Context(map: [:])
    let map_direct = fn(anon from: Label, anon to: Label, anon available_epsilon: Epsilon) -> f64 => 1.0f64 // todo!
    mut lattice = LabelLattice::make(
        hierarchy: [
            "Public": []
            "L1": ["Public"]
            "L2": ["L1"]
            "L3": ["Public"]
        ] as! [Label:[Label]]
        epsilon_map: [
            "Public": Epsilon::Fixed(0f64)
            "L1": Epsilon::RuntimeVar(name: "e1")
            "L2": Epsilon::RuntimeVar(name: "e2")
        ] as! [Label:Epsilon]
        &map_direct
    )

    epsilon_context.insert(EpsilonId(id: 0), Epsilon::Fixed(1f64))
    epsilon_context.insert(EpsilonId(id: 1), Epsilon::Fixed(1f64))

    // let variable_type = make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: 0i64, to: 10000i64)))
    // type_context.insert("x", variable_type)
    let variable_sens = SensitivityId(id: 0)
    sensitivity_context.insert(variable_sens, 1f64)
    // type_level_sensitivity_context.insert(variable_type, variable_sens)

    let pair_left = make_type(&mut type_map
        Type::TypeWithSec(
            type: make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: -1000i64, to: 1000i64)))
            label: Label(name: "L3")
            epsilon: EpsilonId(id: 0)
    ))
    let pair_right = make_type(&mut type_map
        Type::TypeWithSec(
            type: make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: -1000i64, to: 1000i64)))
            label: Label(name: "L2")
            epsilon: EpsilonId(id: 1)
    ))
    let pairs = make_type(&mut type_map, Type::Pair(left: pair_left, right: pair_right))

    let list_sens = SensitivityId(id: 1)
    sensitivity_context.insert(list_sens, 1f64)
    let list_type = make_type(
        &mut type_map
        Type::List(type: pairs, size: 100)
    )
    type_context.insert("list", list_type)
    type_level_sensitivity_context.insert(list_type, list_sens)

    mut e1 = Expression::Variable(name: "i")
    mut e2 = Expression::Variable(name: "x")
    mut e3 = Expression::Variable(name: "x")
    mut expr = Expression::Operation(
        op: Operation::Mul
        operands: [
            e1,
            Expression::Declassify(
                expr: Expression::Subscript(
                    expr: e2
                    index: Expression::IntLiteral(value: 0)
                )
                source_epsilon: EpsilonId(id: 0)
                target_label: Label(name: "L2")
                target_epsilon: EpsilonId(id: 1)
            )
        ]
    )

    expr = Expression::Operation(
        op: Operation::Add
        operands: [
            expr,
            Expression::Subscript(
                expr: e2
                index: Expression::IntLiteral(value: 1)
            )
        ]
    )

    let list = Expression::Variable(name: "list")

    let statement = Statement::ForEach(
        var: "x"
        index: "i"
        list
        body: Statement::Expression(expr)
    )

    let checked = typecheck(
        &lattice
        &mut type_map
        &mut type_context
        &mut type_level_sensitivity_context
        &mut epsilon_context
        &mut sensitivity_context
        statement
    )

    eprintln("{}", lattice.render())

    eprintln("Sensitivity context:")
    sensitivity_context.dump()

    println("{}", checked.to_tree(&type_map))
}