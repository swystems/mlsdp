import extern "AK/Math.h" {
    extern fn min<T>(anon a: T, anon b: T) -> T
    extern fn max<T>(anon a: T, anon b: T) -> T
    extern fn log<T>(anon x: T) -> T
    extern fn exp<T>(anon x: T) -> T
    extern fn fabs<T requires(Floating)>(anon x: T) -> T
    extern fn sqrt<T requires(Floating)>(anon x: T) -> T
}

struct SensitivityId { id: u64 }
struct TypeId { id: u64 }
struct EpsilonId { id: u64 }

type SensitivityId implements(Hashable, Equal<SensitivityId>) {
    fn hash(this) -> u32 => .id.hash()
    fn equals(this, anon other: SensitivityId) -> bool => .id == other.id
}
type TypeId implements(Hashable, Equal<TypeId>) {
    fn hash(this) -> u32 => .id.hash()
    fn equals(this, anon other: TypeId) -> bool => .id == other.id
}
type EpsilonId implements(Hashable, Equal<EpsilonId>) {
    fn hash(this) -> u32 => .id.hash()
    fn equals(this, anon other: EpsilonId) -> bool => .id == other.id
}

trait Map<T> { fn map<U>(this, anon f: &fn(anon x: &T) throws -> U) throws -> [U] }
trait Fold<T> {
    fn fold<U>(this, anon init: U, anon f: &fn(anon acc: U, anon x: &T) throws -> U) throws -> U
    fn fold(this, anon f: &fn(anon acc: T, anon x: &T) throws -> T) throws -> T
}
type Array implements(Map<T>, Fold<T>) {
    [[inline()]]
    fn map<U>(this, anon f: &fn(anon x: &T) throws -> U) throws -> [U] {
        mut result: [U] = []
        result.ensure_capacity(.size())
        for x in this {
            result.push(f(&x))
        }
        return result
    }
    [[inline()]]
    fn fold<U>(this, anon init: U, anon f: &fn(anon acc: U, anon x: &T) throws -> U) throws -> U {
        mut acc = init
        for x in this {
            acc = f(acc, &x)
        }
        return acc
    }
    [[inline()]]
    fn fold(this, anon f: &fn(anon acc: T, anon x: &T) throws -> T) throws -> T {
        mut acc = this[0]
        for x in this[1..] {
            acc = f(acc, &x)
        }
        return acc
    }
}

fn unchecked() -> TypeId => TypeId(id: 0)

class SensitivityMapped<T> {
    public value: T
    public sensitivity: SensitivityId?
    public sensitivity_multiplier: f64 = 1f64
}

enum InferredRange<T> {
    Unknown
    Bounded(from: T, to: T)
}

struct Label implements(Equal<Label>) {
    name: String
    fn equals(this, anon other: Label) -> bool => .name == other.name
}

boxed enum Type {
    Unchecked
    Int(InferredRange<i64>)
    Bool(InferredRange<bool>)
    List(type: TypeId, size: usize)
    TypeWithSec(type: TypeId, label: Label, epsilon: EpsilonId)

    fn render(this, anon type_map: &[TypeId: Type]) throws -> String => match this {
        Unchecked => "unchecked"
        Int(range) => match range {
            Unknown => "int"
            Bounded(from: from, to: to) => format("int({}..{})", from, to)
        }
        Bool(range) => match range {
            Unknown => "bool"
            Bounded(from: from, to: to) => format("bool({}..{})", from, to)
        }
        List(type, size) => format("list {} {}", type_map[type].render(type_map), size)
        TypeWithSec(type: type_id, label: label, epsilon: epsilon) => {
            let inner = type_map[type_id].render(type_map)
            return format("{} lab({}) eps(e{})", inner, label.name, epsilon.id)
        }
    }
}

enum Operation {
    Add, Sub, Mul, Div
}

boxed enum Expression {
    type: SensitivityMapped<TypeId> = SensitivityMapped(value: unchecked(), sensitivity: None)

    IntLiteral(value: i64)
    Variable(name: String)
    Noise(expr: Expression, epsilon: EpsilonId)
    Declassify(expr: Expression, source_epsilon: EpsilonId, target_label: Label, target_epsilon: EpsilonId)
    Subscript(expr: Expression, index: Expression)
    Operation(op: Operation, operands: Array<Expression>)

    fn with_type(this, anon type: TypeId, sensitivity: SensitivityId? = None) -> Expression {
        mut sens = SensitivityMapped(value: .type.value, sensitivity: .type.sensitivity)
        if .type.value == unchecked() {
            sens.value = type
            if sensitivity is Some(value) {
                sens.sensitivity = value
            }
        }

        return match this {
            IntLiteral(value) => Expression::IntLiteral(type: sens, value)
            Variable(name) => Expression::Variable(type: sens, name)
            Noise(expr, epsilon) => Expression::Noise(type: sens, expr, epsilon)
            Declassify(expr, source_epsilon, target_label, target_epsilon) => Expression::Declassify(type: sens, expr, source_epsilon, target_label, target_epsilon)
            Subscript(expr, index) => Expression::Subscript(type: sens, expr, index)
            Operation(op, operands) => Expression::Operation(type: sens, op, operands)
        }
    }

    fn add_sensitivity(mut this, sensitivity_context: &mut Context<SensitivityId, f64>) -> Expression {
        mut sens = SensitivityMapped(value: .type.value, sensitivity: .type.sensitivity)
        if .type.sensitivity is None {
            let id = SensitivityId(id: sensitivity_context.map.size() as! u64)
            sensitivity_context.map.set(id, 1f64)
            sens.sensitivity = id
            match this { else(&mut type) => { type.sensitivity = id } }
        } else {
            let id = .type.sensitivity!
            let value = sensitivity_context.lookup(id)
            sensitivity_context.map.set(id, value + 1f64)
        }

        return match this {
            IntLiteral(value) => Expression::IntLiteral(type: sens, value)
            Variable(name) => Expression::Variable(type: sens, name)
            Noise(expr, epsilon) => Expression::Noise(type: sens, expr, epsilon)
            Declassify(expr, source_epsilon, target_label, target_epsilon) => Expression::Declassify(type: sens, expr, source_epsilon, target_label, target_epsilon)
            Subscript(expr, index) => Expression::Subscript(type: sens, expr, index)
            Operation(op, operands) => Expression::Operation(type: sens, op, operands)
        }
    }

    fn to_tree(this, type_map: &[TypeId:Type], indent: usize = 0) throws => match this {
        IntLiteral(value: x) => println("{: >{}}int({}) type={} sens=s{}*{}", "", indent, x, type_map[.type.value].render(type_map), .type.sensitivity?.id, .type.sensitivity_multiplier)
        Variable(name: x) => println("{: >{}}var({}) type={} sens=s{}*{}", "", indent, x, type_map[.type.value].render(type_map), .type.sensitivity?.id, .type.sensitivity_multiplier)
        Noise(expr, epsilon) => {
            abort()
        }
        Declassify(expr, source_epsilon, target_label, target_epsilon) => {
            abort()
        }
        Subscript(expr, index) => {
            abort()
        }
        Operation(op, operands) => {
            println("{: >{}}op({}) type={} sens=s{}*{}", "", indent, op, type_map[.type.value].render(type_map), .type.sensitivity?.id, .type.sensitivity_multiplier)
            for operand in operands {
                operand.to_tree(type_map, indent: indent + 2)
            }
        }
    }
}

boxed enum Statement {
    type: SensitivityMapped<TypeId> = SensitivityMapped(value: unchecked(), sensitivity: None)

    Expression(Expression)
    ForEach(var: String, index: String, list: Expression, body: Statement)
    Return(Expression)
    IfThenElse(condition: Expression, consequence: Statement, alternative: Statement)
    Assign(var: String, value: Expression)
    Sequence(first: Statement, second: Statement)
}

struct Procedure {
    name: String
    parameters: [String:SensitivityMapped<TypeId>]
    return_type: TypeId
    body: Statement
}

class Context<K requires(Hashable), V> {
    public map: [K:V]
    public base: Context<K, V>? = None

    public fn lookup(this, anon key: K) -> V {
        if not .map.contains(key) {
            if .base is Some(base) { return base.lookup(key) }
            eprintln("Key not found: '{}'", key)
            abort()
        }
        return .map[key]
    }
    public fn find(this, anon key: K) -> V? {
        if .map.contains(key) { return .map[key] }
        if .base is Some(base) { return base.find(key) }
        return None
    }

    public fn insert(mut this, anon key: K, anon value: V) throws { .map.set(key, value) }

    public fn dump(this) {
        for (key, value) in .map {
            eprintln("  {}: {}", key, value)
        }
        if .base is Some(base) { base.dump() }
    }
}

fn child_context<K requires(Hashable), V>(anon parent: Context<K, V>) -> Context<K, V> {
    return Context(map: [:], base: Some(parent))
}

fn make_type(
    type_map: &mut [TypeId:Type]
    anon type: Type
) -> TypeId {
    let id = TypeId(id: type_map.size() as! u64)
    type_map.set(id, type)
    return id
}

fn merge_bounds(
    type_map: &mut [TypeId: Type]
    anon type1: Type
    anon type2: Type
    op: Operation
) throws -> Type => match type1 {
    Unchecked => type2
    Int(range1) => match type2 {
        Int(range2) => Type::Int(match range1 {
            Unknown => range1
            Bounded(from: from1, to: to1) => match range2 {
                Unknown => range2
                Bounded(from: from2, to: to2) => match op {
                    Add => InferredRange::Bounded(from: from1 + from2, to: to1 + to2)
                    Sub => InferredRange::Bounded(from: from1 - to2, to: to1 - from2)
                    Mul => InferredRange::Bounded(
                        from: min(min(from1 * from2, from1 * to2), min(to1 * from2, to1 * to2))
                        to: max(max(from1 * from2, from1 * to2), max(to1 * from2, to1 * to2))
                    )
                    Div => match from2 == 0 or to2 == 0 {
                        true => InferredRange::Unknown
                        false => InferredRange::Bounded(from: min(min(from1 / from2, from1 / to2), min(to1 / from2, to1 / to2)) to: max(max(from1 / from2, from1 / to2), max(to1 / from2, to1 / to2)))
                    }
                }
            }
        })
        else => {
            eprintln("Type mismatch between {} and {}", type1, type2)
            return type1
        }
    }
    Bool(range1) => match type2 {
        Bool(range2) => Type::Bool(match range1 {
            Unknown => range1
            Bounded(from: from1, to: to1) => match range2 {
                Unknown => range2
                Bounded(from: from2, to: to2) => match op {
                    // Add: OR, Mul: AND, Sub: AND NOT, Div: AND NOT; TODO: Split into actual bool operations.
                    Add => InferredRange::Bounded(from: from1 or from2, to: to1 or to2)
                    Mul => InferredRange::Bounded(from: from1 and from2, to: to1 and to2)
                    Sub => InferredRange::Bounded(from: from1 and not to2, to: to1 and not from2)
                    Div => InferredRange::Bounded(from: from1 and not to2, to: to1 and not from2)
                }
            }
        })
        else => {
            eprintln("Type mismatch between {} and {}", type1, type2)
            return type1
        }
    }
    List => {
        eprintln("TODO: Implement list type merging")
        return type1
    }
    TypeWithSec(type: type_id1, label: label1, epsilon: epsilon1) => match type2 {
        TypeWithSec(type: type_id2, label: label2, epsilon: epsilon2) => {
            if label1 != label2 {
                eprintln("Label mismatch between {} and {}", type1, type2)
                return type1
            }
            if epsilon1 != epsilon2 { // FIXME: Epsilon merging
                eprintln("Epsilon mismatch between {} and {}", type1, type2)
                return type1
            }
            let inner = merge_bounds(type_map, type_map[type_id1], type_map[type_id2], op)
            yield Type::TypeWithSec(type: make_type(type_map, inner), label: label1, epsilon: epsilon1)
        }
        else => {
            let inner = merge_bounds(type_map, type_map[type_id1], type2, op)
            yield Type::TypeWithSec(type: make_type(type_map, inner), label: label1, epsilon: epsilon1)
        }
    }
}

fn smooth(anon existing: f64, anon local: f64, beta: f64) -> f64 {
    let result = existing * exp(-beta * local)
    print("Smoothed {} with {} and {} to {}\n", existing, local, beta, result)
    return result
}

fn max_difference_for(anon x: &Type, anon type_map: &[TypeId: Type]) -> f64? => match x {
    Int(range) => match range {
        Unknown => None // TODO: Implement infinite sensitivity
        Bounded(from, to) => fabs(to as! f64 - from as! f64)
    }
    Bool => 1f64
    TypeWithSec(type) => max_difference_for(&type_map[type], type_map)
    else => None
}

fn sens_merge(
    anon sens1: SensitivityId?
    anon sens2: SensitivityId?
    op: Operation
    local_sensitivity: f64
    sensitivity_context: &mut Context<SensitivityId, f64>
    type_map: &mut [TypeId: Type]
    anon lhs: Type
    anon rhs: Type
) -> SensitivityId? {
    if sens1 is None { return sens2 }
    if sens2 is None { return None }

    let s1 = sens1!
    let s2 = sens2!

    let value1 = sensitivity_context.lookup(s1)
    let value2 = sensitivity_context.lookup(s2)

    guard max_difference_for(&lhs, &type_map) is Some(lhs_max_diff)
        and max_difference_for(&rhs, &type_map) is Some(rhs_max_diff)
        else { return None }
    let result = match op {
        Add | Sub => value1 + value2 + local_sensitivity
        Mul | Div => value1 * rhs_max_diff + value2 * lhs_max_diff + local_sensitivity
    }

    let id = SensitivityId(id: sensitivity_context.map.size() as! u64)
    sensitivity_context.map.set(id, result)
    return id
}

fn typecheck(
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, f64>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon mut expr: Expression
) throws -> Expression => match expr {
    IntLiteral(value) => expr.with_type(make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: value, to: value))))
    Variable(name) => {
        let type = type_context.lookup(name)
        yield expr.with_type(
            type
            sensitivity: type_level_sensitivity_context.find(type)
        ).add_sensitivity(sensitivity_context)
    }
    Operation(op, operands) => {
        let checked_operands = operands.map(
            &fn[
                &mut type_map
                &mut type_context
                &mut type_level_sensitivity_context
                &mut epsilon_context
                &mut sensitivity_context
            ](anon x: &Expression) throws -> (Expression, Context<SensitivityId, f64>) {
                mut new_sensitivity_context = child_context(*sensitivity_context)
                let result = typecheck(type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context: &mut new_sensitivity_context, *x)
                return (result, new_sensitivity_context)
            }
        )
        let type = checked_operands.map(
            &fn(anon x: &(Expression, Context<SensitivityId, f64>)) throws -> (SensitivityMapped<TypeId>, Context<SensitivityId, f64>) => (x.0.type, x.1)
        ).fold(
            &fn[
                &mut type_map
                &mut type_context
                &mut epsilon_context
                &mut sensitivity_context
                op
            ](anon acc: (SensitivityMapped<TypeId>, Context<SensitivityId, f64>), anon x: &(SensitivityMapped<TypeId>, Context<SensitivityId, f64>)) throws -> (SensitivityMapped<TypeId>, Context<SensitivityId, f64>) {
                let acc_type = type_map[acc.0.value]
                let x_type = type_map[x.0.value]
                // FIXME: Implement type unification + sensitivity merging
                let local_sensitivity = match x.0.sensitivity.has_value() {
                    true => x.1.lookup(x.0.sensitivity!)
                    false => 0f64
                }
                let sensitivity = sens_merge(acc.0.sensitivity, x.0.sensitivity, op, local_sensitivity, &mut sensitivity_context, &mut type_map, acc_type, x_type)
                eprintln("Merging types {} and {} with op {} and sensitivity {}", acc_type, x_type, op, sensitivity)
                let sens = SensitivityMapped(
                    value: make_type(type_map, merge_bounds(type_map, acc_type, x_type, op))
                    sensitivity
                )
                return (sens, acc.1)
            }
        ).0

        let operands = checked_operands.map(&fn(anon x: &(Expression, Context<SensitivityId, f64>)) throws => x.0)

        yield Expression::Operation(type, op, operands)
    }
    else => {
        eprintln("Typecheck not implemented for ", expr)
        abort()
    }
}

fn main() {
    mut type_map: [TypeId:Type] = [unchecked(): Type::Unchecked]
    mut type_context: Context<String, TypeId> = Context(map: [:])
    mut type_level_sensitivity_context: Context<TypeId, SensitivityId> = Context(map: [:])
    mut epsilon_context: Context<EpsilonId, f64> = Context(map: [:])
    mut sensitivity_context: Context<SensitivityId, f64> = Context(map: [:])

    let variable_type = make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: 0i64, to: 10000i64)))
    type_context.insert("x", variable_type)
    let variable_sens = SensitivityId(id: 0)
    sensitivity_context.insert(variable_sens, 1f64)
    type_level_sensitivity_context.insert(variable_type, variable_sens)

    mut e1 = Expression::IntLiteral(value: 42).with_type(
        make_type(
            &mut type_map
            Type::TypeWithSec(
                type: make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: 0i64, to: 100i64)))
                label: Label(name: "public")
                epsilon: EpsilonId(id: 0)
            )
        )
    )
    mut e2 = Expression::Variable(name: "x")
    mut e3 = Expression::Variable(name: "x")
    mut expr = Expression::Operation(
        op: Operation::Add
        operands: [e1, e2]
    )
    expr = Expression::Operation(
        op: Operation::Mul
        operands: [expr, e3]
    )

    let checked = typecheck(&mut type_map, &mut type_context, &mut type_level_sensitivity_context, &mut epsilon_context, &mut sensitivity_context, expr)

    eprintln("Sensitivity context:")
    sensitivity_context.dump()

    checked.to_tree(&type_map)
}