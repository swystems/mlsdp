import extern "AK/Math.h" {
    extern fn min<T>(anon a: T, anon b: T) -> T
    extern fn max<T>(anon a: T, anon b: T) -> T
    extern fn log<T>(anon x: T) -> T
    extern fn exp<T>(anon x: T) -> T
    extern fn fabs<T requires(Floating)>(anon x: T) -> T
    extern fn sqrt<T requires(Floating)>(anon x: T) -> T
}

struct SensitivityId { id: u64 }
struct TypeId { id: u64 }
struct EpsilonId { id: u64 }

type SensitivityId implements(Hashable, Equal<SensitivityId>) {
    fn hash(this) -> u32 => .id.hash()
    fn equals(this, anon other: SensitivityId) -> bool => .id == other.id
}
type TypeId implements(Hashable, Equal<TypeId>) {
    fn hash(this) -> u32 => .id.hash()
    fn equals(this, anon other: TypeId) -> bool => .id == other.id
}
type EpsilonId implements(Hashable, Equal<EpsilonId>) {
    fn hash(this) -> u32 => .id.hash()
    fn equals(this, anon other: EpsilonId) -> bool => .id == other.id
}

trait Map<T> { fn map<U>(this, anon f: &fn(anon x: &T) throws -> U) throws -> [U] }
trait Fold<T> {
    fn fold<U>(this, anon init: U, anon f: &fn(anon acc: U, anon x: &T) throws -> U) throws -> U
    fn fold(this, anon f: &fn(anon acc: T, anon x: &T) throws -> T) throws -> T
}
type Array implements(Map<T>, Fold<T>) {
    [[inline()]]
    fn map<U>(this, anon f: &fn(anon x: &T) throws -> U) throws -> [U] {
        mut result: [U] = []
        result.ensure_capacity(.size())
        for x in this {
            result.push(f(&x))
        }
        return result
    }
    [[inline()]]
    fn fold<U>(this, anon init: U, anon f: &fn(anon acc: U, anon x: &T) throws -> U) throws -> U {
        mut acc = init
        for x in this {
            acc = f(acc, &x)
        }
        return acc
    }
    [[inline()]]
    fn fold(this, anon f: &fn(anon acc: T, anon x: &T) throws -> T) throws -> T {
        mut acc = this[0]
        for x in this[1..] {
            acc = f(acc, &x)
        }
        return acc
    }
}

fn unchecked() -> TypeId => TypeId(id: 0)

class SensitivityMapped<T> {
    public value: T
    public sensitivity: SensitivityId?
    public sensitivity_multiplier: f64 = 1f64
}

enum InferredRange<T> {
    Unknown
    Bounded(from: T, to: T)
}

struct Label implements(Equal<Label>) {
    name: String
    fn equals(this, anon other: Label) -> bool => .name == other.name
}

boxed enum Type {
    Unchecked
    Int(InferredRange<i64>)
    Bool(InferredRange<bool>)
    List(type: TypeId, size: usize)
    Pair(left: TypeId, right: TypeId)
    TypeWithSec(type: TypeId, label: Label, epsilon: EpsilonId)

    fn element_type(this, type_map: &mut [TypeId:Type]) -> TypeId => match this {
        List(type) => type
        TypeWithSec(type, label, epsilon) => make_type(type_map, Type::TypeWithSec(type, label, epsilon))
        else => {
            eprintln("Invalid element type request for {}", this)
            abort()
        }
    }

    fn element_count(this, type_map: &[TypeId:Type]) -> usize => match this {
        List(size) => size
        Pair => 2
        TypeWithSec(type) => type_map[type].element_count(type_map)
        else => 1
    }

    fn render(this, anon type_map: &[TypeId: Type]) throws -> String => match this {
        Unchecked => "unchecked"
        Int(range) => match range {
            Unknown => "int"
            Bounded(from: from, to: to) => format("int({}..{})", from, to)
        }
        Bool(range) => match range {
            Unknown => "bool"
            Bounded(from: from, to: to) => format("bool({}..{})", from, to)
        }
        List(type, size) => format("list {} {}", type_map[type].render(type_map), size)
        Pair(left, right) => format("{} Ã— {}", type_map[left].render(type_map), type_map[right].render(type_map))
        TypeWithSec(type: type_id, label: label, epsilon: epsilon) => {
            let inner = type_map[type_id].render(type_map)
            return format("{} lab({}) eps(e{})", inner, label.name, epsilon.id)
        }
    }
}

enum Operation {
    Add, Sub, Mul, Div, Pair
}

boxed enum Expression {
    type: SensitivityMapped<TypeId> = SensitivityMapped(value: unchecked(), sensitivity: None)

    IntLiteral(value: i64)
    Variable(name: String)
    Noise(expr: Expression, epsilon: EpsilonId)
    Declassify(expr: Expression, source_epsilon: EpsilonId, target_label: Label, target_epsilon: EpsilonId)
    Subscript(expr: Expression, index: Expression)
    Operation(op: Operation, operands: Array<Expression>)

    fn with_type(this, anon type: TypeId, sensitivity: SensitivityId? = None, sensitivity_multiplier: f64 = 1.0) -> Expression {
        mut sens = SensitivityMapped(value: .type.value, sensitivity: .type.sensitivity)
        if .type.value == unchecked() {
            sens.value = type
            if sensitivity is Some(value) {
                sens.sensitivity = value
                sens.sensitivity_multiplier = sensitivity_multiplier
            }
        }

        return match this {
            IntLiteral(value) => Expression::IntLiteral(type: sens, value)
            Variable(name) => Expression::Variable(type: sens, name)
            Noise(expr, epsilon) => Expression::Noise(type: sens, expr, epsilon)
            Declassify(expr, source_epsilon, target_label, target_epsilon) => Expression::Declassify(type: sens, expr, source_epsilon, target_label, target_epsilon)
            Subscript(expr, index) => Expression::Subscript(type: sens, expr, index)
            Operation(op, operands) => Expression::Operation(type: sens, op, operands)
        }
    }

    fn add_sensitivity(mut this, sensitivity_context: &mut Context<SensitivityId, f64>) -> Expression {
        mut sens = SensitivityMapped(value: .type.value, sensitivity: .type.sensitivity)
        if .type.sensitivity is None {
            let id = SensitivityId(id: sensitivity_context.map.size() as! u64)
            sensitivity_context.map.set(id, 1f64)
            sens.sensitivity = id
            match this { else(&mut type) => { type.sensitivity = id } }
        } else {
            let id = .type.sensitivity!
            let value = sensitivity_context.lookup(id)
            sensitivity_context.map.set(id, value + 1f64)
        }

        return match this {
            IntLiteral(value) => Expression::IntLiteral(type: sens, value)
            Variable(name) => Expression::Variable(type: sens, name)
            Noise(expr, epsilon) => Expression::Noise(type: sens, expr, epsilon)
            Declassify(expr, source_epsilon, target_label, target_epsilon) => Expression::Declassify(type: sens, expr, source_epsilon, target_label, target_epsilon)
            Subscript(expr, index) => Expression::Subscript(type: sens, expr, index)
            Operation(op, operands) => Expression::Operation(type: sens, op, operands)
        }
    }

    fn to_tree(this, type_map: &[TypeId:Type], indent: usize = 0) throws -> String => match this {
        IntLiteral(
            value: x
        ) => format(
            "{: >{}}int({}) type={} sens=s{}*{}"
            ""
            indent
            x
            type_map[.type.value].render(type_map)
            .type.sensitivity?.id
            .type.sensitivity_multiplier
        )
        Variable(
            name: x
        ) => format(
            "{: >{}}var({}) type={} sens=s{}*{}"
            ""
            indent
            x
            type_map[.type.value].render(type_map)
            .type.sensitivity?.id
            .type.sensitivity_multiplier
        )
        Noise(expr, epsilon) => {
            abort()
        }
        Declassify(expr, source_epsilon, target_label, target_epsilon) => {
            abort()
        }
        Subscript(
            expr
            index
        ) => format(
            "{: >{}}sub({}) {} type={} sens=s{}*{}"
            ""
            indent
            index.to_tree(type_map, indent: 0)
            expr.to_tree(type_map, indent: 0)
            type_map[.type.value].render(type_map)
            .type.sensitivity?.id
            .type.sensitivity_multiplier
        )
        Operation(op, operands) => {
            mut x = format(
                "{: >{}}op({}) type={} sens=s{}*{}"
                ""
                indent
                op
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            )
            for operand in operands {
                x += "\n" + operand.to_tree(type_map, indent: indent + 2)
            }
            yield x
        }
    }
}

boxed enum Statement {
    type: SensitivityMapped<TypeId> = SensitivityMapped(value: unchecked(), sensitivity: None)

    Expression(Expression)
    ForEach(var: String, index: String, list: Expression, body: Statement)
    Return(Expression)
    IfThenElse(condition: Expression, consequence: Statement, alternative: Statement)
    Assign(var: String, value: Expression)
    Sequence(first: Statement, second: Statement)

    fn with_type(this, anon type: TypeId, sensitivity: SensitivityId? = None, sensitivity_multiplier: f64 = 1.0) -> Statement {
        mut sens = SensitivityMapped(value: .type.value, sensitivity: .type.sensitivity)
        if .type.value == unchecked() {
            sens.value = type
            if sensitivity is Some(value) {
                sens.sensitivity = value
                sens.sensitivity_multiplier = sensitivity_multiplier
            }
        }

        return match this {
            Expression(expr) => Statement::Expression(type: sens, expr)
            ForEach(var, index, list, body) => Statement::ForEach(type: sens, var, index, list, body)
            Return(expr) => Statement::Return(type: sens, expr)
            IfThenElse(condition, consequence, alternative) => Statement::IfThenElse(type: sens, condition, consequence, alternative)
            Assign(var, value) => Statement::Assign(type: sens, var, value)
            Sequence(first, second) => Statement::Sequence(type: sens, first, second)
        }
    }

    fn to_tree(this, type_map: &[TypeId: Type], indent: usize = 0) throws -> String => match this {
        Expression(expr) => expr.to_tree(type_map, indent: indent)
        ForEach(var, index, list, body) =>
            format(
                "{: >{}}for {} in [{}] type={} sens=s{}*{}\n"
                ""
                indent
                var
                list.to_tree(type_map, indent)
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            ) + body.to_tree(type_map, indent: indent + 2)
        Return(expr) =>
            format(
                "{: >{}}return type={} sens=s{}*{}"
                ""
                indent
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            ) + expr.to_tree(type_map, indent: indent + 2)
        IfThenElse(condition, consequence, alternative) =>
            format(
                "{: >{}}if type={} sens=s{}*{} then\n"
                ""
                indent
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            ) + consequence.to_tree(type_map, indent: indent + 2) + "\nelse\n" + alternative.to_tree(type_map, indent: indent + 2)
        Assign(var, value) =>
            format(
                "{: >{}}{} = {} type={} sens=s{}*{}"
                ""
                indent
                var
                value.to_tree(type_map, indent)
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            )
        Sequence(first, second) =>
            first.to_tree(type_map, indent: indent) + " ; " + second.to_tree(type_map, indent: indent)
    }
}

struct Procedure {
    name: String
    parameters: [String:SensitivityMapped<TypeId>]
    return_type: TypeId
    body: Statement
}

class Context<K requires(Hashable), V> {
    public map: [K:V]
    public base: Context<K, V>? = None

    public fn lookup(this, anon key: K) -> V {
        if not .map.contains(key) {
            if .base is Some(base) { return base.lookup(key) }
            eprintln("Key not found: '{}'", key)
            eprintln("  in context: {}", this)
            abort()
        }
        return .map[key]
    }
    public fn find(this, anon key: K) -> V? {
        if .map.contains(key) { return .map[key] }
        if .base is Some(base) { return base.find(key) }
        return None
    }

    public fn insert(mut this, anon key: K, anon value: V) throws { .map.set(key, value) }

    public fn dump(this) {
        for (key, value) in .map {
            eprintln("  {}: {}", key, value)
        }
        if .base is Some(base) { base.dump() }
    }
}

fn child_context<K requires(Hashable), V>(anon parent: Context<K, V>) -> Context<K, V> {
    return Context(map: [:], base: Some(parent))
}

fn make_type(
    type_map: &mut [TypeId:Type]
    anon type: Type
) -> TypeId {
    let id = TypeId(id: type_map.size() as! u64)
    type_map.set(id, type)
    return id
}

fn merge_bounds(
    type_map: &mut [TypeId: Type]
    anon type1: Type
    anon type2: Type
    op: Operation
) throws -> Type => match type1 {
    Unchecked => type2
    Int(range1) => match type2 {
        Int(range2) => Type::Int(match range1 {
            Unknown => range1
            Bounded(from: from1, to: to1) => match range2 {
                Unknown => range2
                Bounded(from: from2, to: to2) => match op {
                    Add => InferredRange::Bounded(from: from1 + from2, to: to1 + to2)
                    Sub => InferredRange::Bounded(from: from1 - to2, to: to1 - from2)
                    Mul => InferredRange::Bounded(
                        from: min(min(from1 * from2, from1 * to2), min(to1 * from2, to1 * to2))
                        to: max(max(from1 * from2, from1 * to2), max(to1 * from2, to1 * to2))
                    )
                    Div => match from2 == 0 or to2 == 0 {
                        true => InferredRange::Unknown
                        false => InferredRange::Bounded(from: min(min(from1 / from2, from1 / to2), min(to1 / from2, to1 / to2)) to: max(max(from1 / from2, from1 / to2), max(to1 / from2, to1 / to2)))
                    }
                    Pair => {
                        eprintln("Invalid operation for int: Pair")
                        abort()
                    }
                }
            }
        })
        else => {
            eprintln("Type mismatch between {} and {}", type1, type2)
            return type1
        }
    }
    Bool(range1) => match type2 {
        Bool(range2) => Type::Bool(match range1 {
            Unknown => range1
            Bounded(from: from1, to: to1) => match range2 {
                Unknown => range2
                Bounded(from: from2, to: to2) => match op {
                    // Add: OR, Mul: AND, Sub: AND NOT, Div: AND NOT; TODO: Split into actual bool operations.
                    Add => InferredRange::Bounded(from: from1 or from2, to: to1 or to2)
                    Mul => InferredRange::Bounded(from: from1 and from2, to: to1 and to2)
                    Sub => InferredRange::Bounded(from: from1 and not to2, to: to1 and not from2)
                    Div => InferredRange::Bounded(from: from1 and not to2, to: to1 and not from2)
                    Pair => {
                        eprintln("Invalid operation for int: Pair")
                        abort()
                    }
                }
            }
        })
        else => {
            eprintln("Type mismatch between {} and {}", type1, type2)
            return type1
        }
    }
    Pair(left, right) => {
        let left_type = type_map[left]
        let right_type = type_map[right]
        let new_left = merge_bounds(type_map, left_type, type2, op)
        let new_right = merge_bounds(type_map, right_type, type2, op)
        yield Type::Pair(left: make_type(type_map, new_left), right: make_type(type_map, new_right))
    }
    List => {
        eprintln("TODO: Implement list type merging")
        return type1
    }
    TypeWithSec(type: type_id1, label: label1, epsilon: epsilon1) => match type2 {
        TypeWithSec(type: type_id2, label: label2, epsilon: epsilon2) => {
            if label1 != label2 {
                eprintln("Label mismatch between {} and {}", type1, type2)
                return type1
            }
            if epsilon1 != epsilon2 { // FIXME: Epsilon merging
                eprintln("Epsilon mismatch between {} and {}", type1, type2)
                return type1
            }
            let inner = merge_bounds(type_map, type_map[type_id1], type_map[type_id2], op)
            yield Type::TypeWithSec(type: make_type(type_map, inner), label: label1, epsilon: epsilon1)
        }
        else => {
            let inner = merge_bounds(type_map, type_map[type_id1], type2, op)
            yield Type::TypeWithSec(type: make_type(type_map, inner), label: label1, epsilon: epsilon1)
        }
    }
}

fn smooth(anon existing: f64, anon local: f64, beta: f64) -> f64 {
    let result = existing * exp(-beta * local)
    print("Smoothed {} with {} and {} to {}\n", existing, local, beta, result)
    return result
}

fn max_difference_for(anon x: &Type, anon type_map: &[TypeId: Type]) -> f64? => match x {
    Int(range) => match range {
        Unknown => None // TODO: Implement infinite sensitivity
        Bounded(from, to) => fabs(to as! f64 - from as! f64)
    }
    Bool => 1f64
    List(type) | TypeWithSec(type) => max_difference_for(&type_map[type], type_map)
    Pair(left, right) => {
        if max_difference_for(&type_map[left], type_map) is Some(left_diff)
            and max_difference_for(&type_map[right], type_map) is Some(right_diff) {
            return max(left_diff, right_diff)
        }
        return None
    }
    else => None
}

fn sens_merge(
    anon sens1: SensitivityId?
    anon sens2: SensitivityId?
    op: Operation
    local_sensitivity: f64
    sensitivity_context: &mut Context<SensitivityId, f64>
    type_map: &mut [TypeId: Type]
    anon lhs: Type
    anon rhs: Type
) -> SensitivityId? {
    if sens1 is None { return sens2 }
    if sens2 is None { return None }

    let s1 = sens1!
    let s2 = sens2!

    let value1 = sensitivity_context.lookup(s1)
    let value2 = sensitivity_context.lookup(s2)

    guard max_difference_for(&lhs, &type_map) is Some(lhs_max_diff)
        and max_difference_for(&rhs, &type_map) is Some(rhs_max_diff)
        else { return None }
    let result = match op {
        Add | Sub => value1 + value2 + local_sensitivity
        Mul | Div => value1 * rhs_max_diff + value2 * lhs_max_diff + local_sensitivity
        Pair => 1f64
    }

    let id = SensitivityId(id: sensitivity_context.map.size() as! u64)
    sensitivity_context.map.set(id, result)
    return id
}

fn typecheck(
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, f64>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon mut expr: Expression
) throws -> Expression => match expr {
    IntLiteral(value) => expr.with_type(make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: value, to: value))))
    Variable(name) => {
        let type = type_context.lookup(name)
        yield expr.with_type(
            type
            sensitivity: type_level_sensitivity_context.find(type)
        ).add_sensitivity(sensitivity_context)
    }
    Subscript(expr, index) => {
        let checked_expr = typecheck(type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, expr)
        let checked_index = typecheck(type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, index)
        mut expr_type = type_map[checked_expr.type.value]
        let unchecked_expr = Expression::Subscript(expr: checked_expr, index: checked_index)
        mut wrap_with_sec = fn(anon type: TypeId) throws => type

        if expr_type is TypeWithSec(type, label, epsilon) {
            wrap_with_sec = fn[
                &mut type_map
                label
                epsilon
            ](anon type: TypeId) throws -> TypeId => make_type(type_map, Type::TypeWithSec(type, label, epsilon))
            expr_type = type_map[type]
        }

        mut result = match expr_type {
            List(type, size) => unchecked_expr.with_type(wrap_with_sec(type))
            Pair(left, right) => match checked_index {
                IntLiteral(value) => match value {
                    0 => unchecked_expr.with_type(wrap_with_sec(left))
                    1 => unchecked_expr.with_type(wrap_with_sec(right))
                    else => {
                        eprintln("Invalid index for pair: {}", value)
                        abort()
                    }
                }
                else => {
                    eprintln("Invalid index type for pair: {}", checked_index)
                    abort()
                }
            }
            else => {
                eprintln("Invalid subscript type: {}", expr_type)
                abort()
            }
        }

        yield result.add_sensitivity(sensitivity_context)
    }
    Operation(op, operands) => {
        let checked_operands = operands.map(
            &fn[
                &mut type_map
                &mut type_context
                &mut type_level_sensitivity_context
                &mut epsilon_context
                &mut sensitivity_context
            ](anon x: &Expression) throws -> (Expression, Context<SensitivityId, f64>) {
                mut new_sensitivity_context = child_context(*sensitivity_context)
                let result = typecheck(type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context: &mut new_sensitivity_context, *x)
                return (result, new_sensitivity_context)
            }
        )
        let type = checked_operands.map(
            &fn(anon x: &(Expression, Context<SensitivityId, f64>)) throws -> (SensitivityMapped<TypeId>, Context<SensitivityId, f64>) => (x.0.type, x.1)
        ).fold(
            &fn[
                &mut type_map
                &mut type_context
                &mut epsilon_context
                &mut sensitivity_context
                op
            ](anon acc: (SensitivityMapped<TypeId>, Context<SensitivityId, f64>), anon x: &(SensitivityMapped<TypeId>, Context<SensitivityId, f64>)) throws -> (SensitivityMapped<TypeId>, Context<SensitivityId, f64>) {
                let acc_type = type_map[acc.0.value]
                let x_type = type_map[x.0.value]
                // FIXME: Implement type unification + sensitivity merging
                let local_sensitivity = match x.0.sensitivity.has_value() {
                    true => x.1.lookup(x.0.sensitivity!)
                    false => 0f64
                }
                let sensitivity = sens_merge(acc.0.sensitivity, x.0.sensitivity, op, local_sensitivity, &mut sensitivity_context, &mut type_map, acc_type, x_type)
                let sens = SensitivityMapped(
                    value: make_type(type_map, merge_bounds(type_map, acc_type, x_type, op))
                    sensitivity
                )
                return (sens, acc.1)
            }
        ).0

        let operands = checked_operands.map(&fn(anon x: &(Expression, Context<SensitivityId, f64>)) throws => x.0)

        yield Expression::Operation(type, op, operands)
    }
    else => {
        eprintln("Typecheck not implemented for ", expr)
        abort()
    }
}

fn typecheck(
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, f64>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon mut stmt: Statement
) throws -> Statement => match stmt {
    Expression(
        expr
    ) => {
        let checked = typecheck(type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, expr)
        yield Statement::Expression(type: checked.type, checked)
    }
    ForEach(var, index, list, body) => {
        let list_expr = typecheck(
            type_map
            type_context
            type_level_sensitivity_context
            epsilon_context
            sensitivity_context
            list
        )
        let list_type = type_map.get(list_expr.type.value)!
        let list_sens = type_level_sensitivity_context.find(list_expr.type.value)
        let entry_var_type = list_type.element_type(&mut type_map)
        mut new_type_context = child_context(*type_context)
        new_type_context.insert(var, entry_var_type)
        let entry_var_sens = SensitivityId(id: sensitivity_context.map.size() as! u64)
        sensitivity_context.insert(entry_var_sens, 1f64)
        type_level_sensitivity_context.insert(entry_var_type, entry_var_sens)
        let index_var_type = make_type(
            &mut type_map
            Type::Int(InferredRange::Bounded(from: 0i64, to: list_type.element_count(&type_map) as! i64 - 1i64))
        )
        new_type_context.insert(index, index_var_type)
        let index_var_sens = SensitivityId(id: sensitivity_context.map.size() as! u64)
        sensitivity_context.insert(index_var_sens, 1f64)
        type_level_sensitivity_context.insert(index_var_type, index_var_sens)

        if sens_merge(
                list_sens
                entry_var_sens
                op: Operation::Add
                local_sensitivity: 0f64
                sensitivity_context
                type_map
                list_type
                type_map.get(entry_var_type)!
            ) is Some(new_sens) {
            type_level_sensitivity_context.insert(entry_var_type, new_sens)
            sensitivity_context.insert(new_sens, 1f64)
        }

        let body_stmt = typecheck(
            type_map
            type_context: &mut new_type_context
            type_level_sensitivity_context
            epsilon_context
            sensitivity_context
            body
        )
        let body_sens = body_stmt.type.sensitivity
        mut loop_sensitivity = body_stmt.type.sensitivity
        mut loop_sensitivity_multiplier = 1f64

        if sens_merge(
            list_sens
            body_sens
            op: Operation::Add
            local_sensitivity: 0f64
            sensitivity_context
            type_map
            type_map.get(list_expr.type.value)!
            type_map.get(body_stmt.type.value)!
        ) is Some(new_sens) {
            type_level_sensitivity_context.insert(body_stmt.type.value, new_sens)
            let total_sensitivity_multiplier = list_type.element_count(&type_map)
            loop_sensitivity = new_sens
            loop_sensitivity_multiplier = total_sensitivity_multiplier as! f64
        }

        yield Statement::ForEach(var, index, list: list_expr, body: body_stmt).with_type(
            type: body_stmt.type.value
            sensitivity: loop_sensitivity
            sensitivity_multiplier: loop_sensitivity_multiplier
        )
    }
    else => {
        eprintln("Typecheck not implemented for ", stmt)
        abort()
    }
}

fn main() {
    mut type_map: [TypeId:Type] = [unchecked(): Type::Unchecked]
    mut type_context: Context<String, TypeId> = Context(map: [:])
    mut type_level_sensitivity_context: Context<TypeId, SensitivityId> = Context(map: [:])
    mut epsilon_context: Context<EpsilonId, f64> = Context(map: [:])
    mut sensitivity_context: Context<SensitivityId, f64> = Context(map: [:])

    // let variable_type = make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: 0i64, to: 10000i64)))
    // type_context.insert("x", variable_type)
    let variable_sens = SensitivityId(id: 0)
    sensitivity_context.insert(variable_sens, 1f64)
    // type_level_sensitivity_context.insert(variable_type, variable_sens)

    let pair_left = make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: -1000i64, to: 1000i64)))
    let pair_right = make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: -1000i64, to: 1000i64)))
    let pairs = make_type(&mut type_map, Type::Pair(left: pair_left, right: pair_right))

    let list_sens = SensitivityId(id: 1)
    sensitivity_context.insert(list_sens, 1f64)
    let list_type = make_type(
        &mut type_map
        Type::List(type: pairs, size: 100)
    )
    type_context.insert("list", list_type)
    type_level_sensitivity_context.insert(list_type, list_sens)

    mut e1 = Expression::Variable(name: "i")
    mut e2 = Expression::Variable(name: "x")
    mut e3 = Expression::Variable(name: "x")
    mut expr = Expression::Operation(
        op: Operation::Mul
        operands: [
            e1,
            Expression::Subscript(
                expr: e2
                index: Expression::IntLiteral(value: 0)
            )
        ]
    )

    expr = Expression::Operation(
        op: Operation::Add
        operands: [
            expr,
            Expression::Subscript(
                expr: e2
                index: Expression::IntLiteral(value: 1)
            )
        ]
    )

    let list = Expression::Variable(name: "list")

    let statement = Statement::ForEach(
        var: "x"
        index: "i"
        list
        body: Statement::Expression(expr)
    )

    let checked = typecheck(&mut type_map, &mut type_context, &mut type_level_sensitivity_context, &mut epsilon_context, &mut sensitivity_context, statement)

    eprintln("Sensitivity context:")
    sensitivity_context.dump()

    println("{}", checked.to_tree(&type_map))
}