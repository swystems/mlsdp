import jakt::prelude::configuration { UserConfiguration }

import extern "AK/Math.h" {
    extern fn min<T>(anon a: T, anon b: T) -> T
    extern fn max<T>(anon a: T, anon b: T) -> T
    extern fn log<T>(anon x: T) -> T
    extern fn exp<T>(anon x: T) -> T
    extern fn fabs<T requires(Floating)>(anon x: T) -> T
    extern fn sqrt<T requires(Floating)>(anon x: T) -> T
}

trait SetTheoric {
    fn union_(this, anon other: Self) -> Self
    fn intersection(this, anon other: Self) -> Self
    fn difference(this, anon other: Self) -> Self
    fn contains(this, anon element: Self) -> bool
}

type Array implements(SetTheoric) {
    [[inline()]]
    fn union_(this, anon other: Array<T>) -> Array<T> {
        mut result = this[..].to_array()
        result.push_values(&other)
        return result
    }
    [[inline()]]
    fn intersection(this, anon other: Array<T>) -> Array<T> {
        mut result: [T] = []
        for x in this {
            if other.contains(x) { result.push(x) }
        }
        return result
    }
    [[inline()]]
    fn difference(this, anon other: Array<T>) -> Array<T> {
        mut result: [T] = []
        for x in this {
            if not other.contains(x) { result.push(x) }
        }
        return result
    }
}

struct SensitivityId { id: u64 }
struct TypeId { id: u64 }
struct EpsilonId { id: u64 }

enum Epsilon {
    Fixed(f64)
    RuntimeVar(name: String)
    Min(a: EpsilonId, b: EpsilonId)
    Max(a: EpsilonId, b: EpsilonId)
    Subtract(a: EpsilonId, b: EpsilonId)
    Multiply(a: EpsilonId, b: EpsilonId)
}

struct Label implements(Equal<Label>, Hashable, FromStringLiteral) {
    name: String
    fn equals(this, anon other: Label) -> bool => .name == other.name
    fn hash(this) -> u32 => .name.hash()
    fn from_string_literal(anon s: StringView) -> Label {
        return Label(name: format("{}", s))
    }
}

class Fnv {
    public func: fn(anon epsilon: Epsilon) -> f64
    public fn call(this, anon epsilon: Epsilon) -> f64 {
        let f = &.func
        return f(epsilon)
    }
}

class LabelLattice {
    public tops: [Label]
    public bottoms: [Label]
    public hierarchy: [Label:[Label]]
    public epsilon_map: [Label:Epsilon]
    // from -> to -> (epsilon -> multiplier for result)
    public map: [Label:[Label:Fnv]]

    [[stores_arguments(map_direct:"return")]]
    public fn make(
        anon hierarchy: [Label:[Label]]
        anon epsilon_map: [Label:Epsilon]
        anon map_direct: &fn(from: Label, to: Label, epsilon: Epsilon) -> f64
    ) throws -> LabelLattice {
        mut tops: [Label] = []
        mut bottoms: [Label] = []
        mut map: [Label:[Label:Fnv]] = [:]
        for label in hierarchy.keys() {
            let dict: [Label:Fnv] = [:]
            map.set(label, dict)
        }

        for (label, lessers) in hierarchy {
            if lessers.size() == 0 {
                bottoms.push(label)
            }
            for lesser in lessers {
                map[lesser].set(label, Fnv(func: fn[&map_direct, lesser, label](anon epsilon: Epsilon) => map_direct(from: lesser, to: label, epsilon)))
            }
        }

        for (label, _) in hierarchy {
            // find top (no entry has this label as a lesser)
            if map.get(label)!.is_empty() {
                tops.push(label)
            }
        }

        return LabelLattice(tops: tops, bottoms: bottoms, hierarchy, epsilon_map, map)
    }

    public fn join(this, anon a: Label, anon b: Label) throws -> Label {
        let a_ancestors = .ancestors(a)
        if a_ancestors.contains(b) { return b }

        let b_ancestors = .ancestors(b)
        if b_ancestors.contains(a) { return a }

        return fold(a_ancestors.intersection(b_ancestors),
            &fn[this](anon acc: Label, anon x: &Label) throws -> Label => match .hierarchy[acc].contains(*x) { true => *x, false => acc }
        )
    }

    public fn ancestors(this, anon label: Label) -> [Label] {
        mut open: [Label] = [label]
        mut closed: [Label] = []
        while open.size() > 0 {
            let current = open.pop()!
            closed.push(current)
            for parent in .hierarchy[current] {
                if not closed.contains(parent) and not open.contains(parent) {
                    open.push(parent)
                }
            }
        }
        return closed[1..].to_array()
    }

    public fn best_path_for(
        this
        from: Label
        to: Label
        epsilon: Epsilon
    ) throws -> ([Label], f64)? {
        mut open: [Label] = [from]
        mut closed: [Label] = []
        mut costs: [Label:f64] = [from: 0f64]
        mut parents: [Label:Label] = [:]

        if .ancestors(from).contains(to) {
            return ([from, to], 0.0f64)
        }

        while open.size() > 0 {
            let current = fold(open,
                &fn[this, &costs](anon acc: Label, anon x: &Label) throws -> Label => match costs[x] < costs[acc] { true => *x, false => acc }
            )
            if current == to {
                mut result: [Label] = [to]
                while not result[0].equals(from) {
                    result.insert(before_index: 0, value: parents[result[0]])
                }
                return (result, costs[to])
            }

            open = open.difference([current])
            closed.push(current)

            for next in .map[current].keys() {
                if closed.contains(next) { continue }
                let cost = costs[current] + .map[current][next].call(epsilon) // Assume epsilon = 1 for now
                if not open.contains(next) or cost < costs[next] {
                    costs.set(next, cost)
                    parents.set(next, current)
                    if not open.contains(next) { open.push(next) }
                }
            }
        }

        // No direct path, try to find a path through a common ancestor
        let common_ancestor = .join(from, to)
        guard .best_path_for(from, to: common_ancestor, epsilon) is Some(fpc)
            and .best_path_for(from: common_ancestor, to, epsilon) is Some(cpt)
            else { return None }
        
        let (from_path, from_cost) = fpc
        let (common_path, common_cost) = cpt
        return (from_path.union_(common_path), from_cost + common_cost)
    }

    fn tree(this, anon label: Label, anon builder: &mut StringBuilder, anon indent: usize = 0) throws {
        builder.appendff("{: >{}}{}\n", "", indent, label)
        for lesser in .hierarchy[label] {
            .tree(lesser, builder, indent: indent + 2)
        }
    }

    public fn render(this) throws -> String {
        mut builder = StringBuilder::create()
        builder.append("Lattice:\n")
        for top in this.tops {
            .tree(top, &mut builder)
        }
        builder.append("Epsilon map:\n")
        for (label, epsilon) in this.epsilon_map {
            builder.appendff("  {}: {}\n", label, epsilon)
        }
        return builder.to_string()
    }

    public fn all_labels(this) -> {Label} {
        mut result: {Label} = {}
        for top in this.tops {
            result.add(top)
            for label in .ancestors(top) {
                result.add(label)
            }
        }
        return result
    }

    public fn all_paths(this, epsilon_context: &mut Context<EpsilonId, Epsilon>) throws -> [(Label, Label, EpsilonId)] {
        mut result: [(Label, Label, EpsilonId)] = []
        mut epsilons: [Label:EpsilonId] = [:]
        for (label, epsilon) in .epsilon_map {
            let id = EpsilonId(id: epsilon_context.map.size() as! u64)
            epsilons.set(label, id)
            epsilon_context.insert(id, epsilon)
        }
        for from in .all_labels() {
            for to in .all_labels() {
                if from == to { continue }
                if .best_path_for(from, to, epsilon: Epsilon::Max(a: epsilons[from], b: epsilons[to])) is Some(v) {
                    let (path, cost) = v
                    let id = EpsilonId(id: epsilon_context.map.size() as! u64)
                    epsilon_context.insert(id, Epsilon::Fixed(cost))
                    result.push((from, to, id))
                }
            }
        }
        return result
    }
}

type SensitivityId implements(Hashable, Equal<SensitivityId>) {
    fn hash(this) -> u32 => .id.hash()
    fn equals(this, anon other: SensitivityId) -> bool => .id == other.id
}
type TypeId implements(Hashable, Equal<TypeId>) {
    fn hash(this) -> u32 => .id.hash()
    fn equals(this, anon other: TypeId) -> bool => .id == other.id
}
type EpsilonId implements(Hashable, Equal<EpsilonId>) {
    fn hash(this) -> u32 => .id.hash()
    fn equals(this, anon other: EpsilonId) -> bool => .id == other.id
}

trait Map<T> { fn map<U>(this, anon f: &fn(anon x: &T) throws -> U) throws -> [U] }
type Array implements(Map<T>) {
    [[inline()]]
    fn map<U>(this, anon f: &fn(anon x: &T) throws -> U) throws -> [U] {
        mut result: [U] = []
        result.ensure_capacity(.size())
        for x in this {
            result.push(f(&x))
        }
        return result
    }
}

fn fold<T>(
    anon list: [T]
    anon f: &fn(anon acc: T, anon x: &T) throws -> T
) throws -> T {
    mut acc = list[0]
    for x in list[1..] {
        acc = f(acc, &x)
    }
    return acc
}

fn unchecked() -> TypeId => TypeId(id: 0)

class SensitivityMapped<T> {
    public value: T
    public sensitivity: SensitivityId?
    public sensitivity_multiplier: f64 = 1f64
}

enum InferredRange<T> {
    Unknown
    Bounded(from: T, to: T)
}

boxed enum Type {
    Unchecked
    Int(InferredRange<i64>)
    Bool(InferredRange<bool>)
    List(type: TypeId, size: usize)
    Pair(left: TypeId, right: TypeId)
    TypeWithSec(type: TypeId, label: Label, epsilon: EpsilonId)

    fn pure_type(this, type_map: &[TypeId:Type]) -> Type => match this {
        TypeWithSec(type) => type_map[type].pure_type(type_map)
        else => this
    }

    fn element_type(this, type_map: &mut [TypeId:Type]) -> TypeId => match this {
        List(type) => type
        TypeWithSec(type, label, epsilon) => make_type(type_map, Type::TypeWithSec(type, label, epsilon))
        else => {
            eprintln("Invalid element type request for {}", this)
            abort()
        }
    }

    fn element_count(this, type_map: &[TypeId:Type]) -> usize => match this {
        List(size) => size
        Pair => 2
        TypeWithSec(type) => type_map[type].element_count(type_map)
        else => 1
    }

    fn label(this, lattice: &LabelLattice) -> Label => match this {
        TypeWithSec(label) => label
        else => lattice.bottoms[0]
    }

    fn epsilon(this, type_map: &[TypeId:Type]) -> EpsilonId => match this {
        TypeWithSec(epsilon) => epsilon
        List(type) => type_map[type].epsilon(type_map)
        else => EpsilonId(id: 0) // FIXME: This is a hack
    }

    fn render(this, anon type_map: &[TypeId: Type], minimal: bool = false) throws -> String => match this {
        Unchecked => "unchecked"
        Int(range) => match minimal {
            true => "int"
            else => match range {
                Unknown => "int"
                Bounded(from: from, to: to) => format("int({}..{})", from, to)
            }
        }
        Bool(range) => match minimal {
            true => "bool"
            else => match range {
                Unknown => "bool"
                Bounded(from: from, to: to) => format("bool({}..{})", from, to)
            }
        }
        List(type, size) => format("list {} {}", type_map[type].render(type_map, minimal), size)
        Pair(left, right) => format("{} × {}", type_map[left].render(type_map, minimal), type_map[right].render(type_map, minimal))
        TypeWithSec(type: type_id, label: label, epsilon: epsilon) => {
            let inner = type_map[type_id].render(type_map, minimal)
            return format("{} lab({}) eps(e{})", inner, label.name, epsilon.id)
        }
    }
}

enum Operation {
    Add, Sub, Mul, Div, Pair, Gt
}

boxed enum Expression {
    type: SensitivityMapped<TypeId> = SensitivityMapped(value: unchecked(), sensitivity: None)

    IntLiteral(value: i64)
    ListLiteral(elements: [Expression])
    Variable(name: String)
    Noise(expr: Expression, epsilon: EpsilonId)
    Declassify(expr: Expression, source_epsilon: EpsilonId, target_label: Label, target_epsilon: EpsilonId, used_epsilon: EpsilonId? = None)
    Subscript(expr: Expression, index: Expression)
    Operation(op: Operation, operands: Array<Expression>)
    Call(procedure: Procedure, arguments: Array<Expression>)
    ForEach(var: String, index: String, accum: String, accum_init: Expression, list: Expression, body: Expression)
    IfThenElse(condition: Expression, consequence: Expression, alternative: Expression)
    Let(var: String, value: Expression, body: Expression)
    Ignore

    fn with_type(this, anon type: TypeId, sensitivity: SensitivityId? = None, sensitivity_multiplier: f64 = 1.0) -> Expression {
        mut sens = SensitivityMapped(value: .type.value, sensitivity: .type.sensitivity)
        if .type.value == unchecked() {
            sens.value = type
            if sensitivity is Some(value) {
                sens.sensitivity = value
                sens.sensitivity_multiplier = sensitivity_multiplier
            }
        }

        return match this {
            IntLiteral(value) => Expression::IntLiteral(type: sens, value)
            ListLiteral(elements) => Expression::ListLiteral(type: sens, elements)
            Variable(name) => Expression::Variable(type: sens, name)
            Noise(expr, epsilon) => Expression::Noise(type: sens, expr, epsilon)
            Declassify(expr, source_epsilon, target_label, target_epsilon, used_epsilon) => Expression::Declassify(type: sens, expr, source_epsilon, target_label, target_epsilon, used_epsilon)
            Subscript(expr, index) => Expression::Subscript(type: sens, expr, index)
            Operation(op, operands) => Expression::Operation(type: sens, op, operands)
            Call(procedure, arguments) => Expression::Call(type: sens, procedure, arguments)
            ForEach(var, index, accum, accum_init, list, body) => Expression::ForEach(type: sens, var, index, accum, accum_init, list, body)
            IfThenElse(condition, consequence, alternative) => Expression::IfThenElse(type: sens, condition, consequence, alternative)
            Let(var, value, body) => Expression::Let(type: sens, var, value, body)
            Ignore => Expression::Ignore
        }
    }

    fn add_sensitivity(mut this, sensitivity_context: &mut Context<SensitivityId, f64>) -> Expression {
        mut sens = SensitivityMapped(value: .type.value, sensitivity: .type.sensitivity)
        if .type.sensitivity is None {
            let id = SensitivityId(id: sensitivity_context.map.size() as! u64)
            sensitivity_context.map.set(id, 1f64)
            sens.sensitivity = id
            match this {
                Ignore => {}
                else(&mut type) => { type.sensitivity = id }
            }
        } else {
            let id = .type.sensitivity!
            let value = sensitivity_context.lookup(id)
            sensitivity_context.map.set(id, value + 1f64)
        }

        return match this {
            IntLiteral(value) => Expression::IntLiteral(type: sens, value)
            ListLiteral(elements) => Expression::ListLiteral(type: sens, elements)
            Variable(name) => Expression::Variable(type: sens, name)
            Noise(expr, epsilon) => Expression::Noise(type: sens, expr, epsilon)
            Declassify(expr, source_epsilon, target_label, target_epsilon) => Expression::Declassify(type: sens, expr, source_epsilon, target_label, target_epsilon)
            Subscript(expr, index) => Expression::Subscript(type: sens, expr, index)
            Operation(op, operands) => Expression::Operation(type: sens, op, operands)
            Call(procedure, arguments) => Expression::Call(type: sens, procedure, arguments)
            ForEach(var, index, accum, accum_init, list, body) => Expression::ForEach(type: sens, var, index, accum, accum_init, list, body)
            IfThenElse(condition, consequence, alternative) => Expression::IfThenElse(type: sens, condition, consequence, alternative)
            Let(var, value, body) => Expression::Let(type: sens, var, value, body)
            Ignore => Expression::Ignore(type: sens)
        }
    }

    fn to_tree(this, type_map: &[TypeId: Type], indent: usize = 0) throws -> String => match this {
        IntLiteral(
            value: x
        ) => format(
            "{: >{}}int({}) type={} sens=s{}*{}"
            ""
            indent
            x
            type_map[.type.value].render(type_map)
            .type.sensitivity?.id
            .type.sensitivity_multiplier
        )
        ListLiteral(
            elements
        ) => {
            mut x = format(
                "{: >{}}list type={} sens=s{}*{}"
                ""
                indent
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            )
            for element in elements {
                x += "\n" + element.to_tree(type_map, indent: indent + 2)
            }
            yield x
        }
        Variable(
            name: x
        ) => format(
            "{: >{}}var({}) type={} sens=s{}*{}"
            ""
            indent
            x
            type_map[.type.value].render(type_map)
            .type.sensitivity?.id
            .type.sensitivity_multiplier
        )
        Noise(expr, epsilon) =>
            format(
                "{: >{}}noise({}) type={} sens=s{}*{}\n"
                ""
                indent
                epsilon
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            ) + expr.to_tree(type_map, indent: indent + 2)
        Declassify(expr, source_epsilon, target_label, used_epsilon) => format(
            "{: >{}}declassify(to={}, used eps={}) type={} sens=s{}*{}\n{}"
            ""
            indent
            target_label.name
            used_epsilon
            type_map[.type.value].render(type_map)
            .type.sensitivity?.id
            .type.sensitivity_multiplier
            expr.to_tree(type_map, indent: indent + 2)
        )
        Subscript(
            expr
            index
        ) => format(
            "{: >{}}sub({}) type={} sens=s{}*{}\n{}"
            ""
            indent
            index.to_tree(type_map, indent: 0)
            type_map[.type.value].render(type_map)
            .type.sensitivity?.id
            .type.sensitivity_multiplier
            expr.to_tree(type_map, indent: indent + 2)
        )
        Operation(op, operands) => {
            mut x = format(
                "{: >{}}op({}) type={} sens=s{}*{}"
                ""
                indent
                op
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            )
            for operand in operands {
                x += "\n" + operand.to_tree(type_map, indent: indent + 2)
            }
            yield x
        }
        Call(procedure, arguments) => {
            mut x = format(
                "{: >{}}call({}) type={} sens=s{}*{}"
                ""
                indent
                procedure.name
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            )
            for argument in arguments {
                x += "\n" + argument.to_tree(type_map, indent: indent + 2)
            }
            yield x
        }
        ForEach(var, index, accum, accum_init, list, body) => {
            mut x = format(
                "{: >{}}for {} in (-> type={} sens=s{}*{})\n"
                ""
                indent
                var
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            )
            x += list.to_tree(type_map, indent: indent + 2)
            x += format("\n{: >{}}do\n", "", indent + 2)
            x += body.to_tree(type_map, indent: indent + 4)
            yield x
        }
        IfThenElse(condition, consequence, alternative) => {
            mut x = format(
                "{: >{}}if type={} sens=s{}*{}\n"
                ""
                indent
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            )
            x += condition.to_tree(type_map, indent: indent + 2)
            x += "\nthen\n"
            x += consequence.to_tree(type_map, indent: indent + 2)
            x += "\nelse\n"
            x += alternative.to_tree(type_map, indent: indent + 2)
            yield x
        }
        Let(var, value, body) => {
            mut x = format(
                "{: >{}}let {} type={} sens=s{}*{} =\n"
                ""
                indent
                var
                type_map[.type.value].render(type_map)
                .type.sensitivity?.id
                .type.sensitivity_multiplier
            )
            x += value.to_tree(type_map, indent: indent + 2)
            x += format("\n{: >{}}in\n", "", indent + 2)
            x += body.to_tree(type_map, indent: indent + 4)
            yield x
        }
        Ignore => format("{: >{}}ignore", "", indent)
    }

fn to_lang(this, type_map: &[TypeId: Type], indent: usize = 0) throws -> String {
    return match this {
        IntLiteral(value) => format("{: >{}}{}", "", indent, value)
        ListLiteral(elements) => {
            mut x = format("{: >{}}[\n", "", indent)
            for element in elements {
                x += element.to_lang(type_map, indent: indent + 2)
                x += ",\n"
            }
            x += format("{: >{}}]", "", indent)
            yield x
        }
        Variable(name) => name
        Noise(expr, epsilon) => format("noise({}, {})", expr.to_lang(type_map), epsilon)
        Declassify(
            expr
            source_epsilon
            target_label
            target_epsilon
            used_epsilon
        ) => format("declassify({}, {}, e{})", expr.to_lang(type_map), target_label.name, target_epsilon.id)
        Subscript(expr, index) => format("{}[{}]", expr.to_lang(type_map), index.to_lang(type_map))
        Operation(op, operands) => {
            let op_value = match op {
                Add => "+"
                Sub => "-"
                Mul => "*"
                Div => "/"
                Pair => ","
                Gt => ">"
            }
            mut builder = StringBuilder::create()
            builder.append("(")
            mut first = true
            for operand in operands {
                if not first { builder.appendff(" {} ", op_value) }
                builder.append(operand.to_lang(type_map))
                first = false
            }
            builder.append(")")
            return builder.to_string()
        }
        Call(procedure, arguments) => {
            mut x = format("{}(\n", procedure.name)
            for argument in arguments {
                x += argument.to_lang(type_map, indent: indent + 2)
                x += ",\n"
            }
            x += format("{: >{}})", "", indent)
            yield x
        }
        ForEach(var, index, accum, accum_init, list, body) => {
            mut x = format("for {} in {} index {} accum {} = {}\n", var, list.to_lang(type_map), index, accum, accum_init.to_lang(type_map))
            x += format("{: >{}}", "", indent + 2)
            x += body.to_lang(type_map, indent: indent + 2)
            yield x
        }
        IfThenElse(condition, consequence, alternative) => {
            yield format(
                "if {} then {} else {}"
                condition.to_lang(type_map)
                consequence.to_lang(type_map)
                alternative.to_lang(type_map)
            )
        }
        Let(var, value, body) => {
            mut x = format("let {} = ", var)
            x += value.to_lang(type_map, indent)
            x += " in\n"
            x += body.to_lang(type_map, indent: indent + 2)
            yield x
        }
        Ignore => ""
    }
}
}

struct Procedure {
    name: String
    parameters: [String:SensitivityMapped<TypeId>]
    return_type: TypeId
    body: Expression

    fn to_tree(this, type_map: &[TypeId:Type], indent: usize = 0) throws -> String {
        mut builder = StringBuilder::create()
        builder.appendff("{: >{}}Procedure {}(\n", "", indent, this.name)
        for (name, type) in this.parameters {
            builder.appendff("{: >{}}  {}: {}\n", "", indent, name, type_map[type.value].render(type_map))
        }
        builder.appendff("{: >{}}) -> {}\n", "", indent, type_map[this.return_type].render(type_map))
        builder.append(this.body.to_tree(type_map, indent: indent + 2))
        return builder.to_string()
    }

    fn to_lang(this, type_map: &[TypeId:Type], indent: usize = 0) throws -> String {
        mut builder = StringBuilder::create()
        builder.appendff("{: >{}}let {} = proc(\n", "", indent, this.name)
        for (name, type) in this.parameters {
            builder.appendff("{: >{}}  {}: {}\n", "", indent, name, type_map[type.value].render(type_map, minimal: true))
        }
        builder.appendff("{: >{}}) -> {}\n", "", indent, type_map[this.return_type].render(type_map, minimal: true))
        builder.append(this.body.to_lang(type_map, indent: indent + 2))
        builder.append("\nin\n")
        return builder.to_string()
    }
}

class Context<K requires(Hashable), V> implements(IntoIterator<(K, V)>) {
    public map: [K:V]
    public base: Context<K, V>? = None

    public fn lookup(this, anon key: K) -> V {
        if not .map.contains(key) {
            if .base is Some(base) { return base.lookup(key) }
            eprintln("Key not found: '{}'", key)
            eprintln("  in context: {}", this)
            abort()
        }
        return .map[key]
    }
    public fn find(this, anon key: K) -> V? {
        if .map.contains(key) { return .map[key] }
        if .base is Some(base) { return base.find(key) }
        return None
    }

    public fn insert(mut this, anon key: K, anon value: V) throws {
        if .base is Some(context) and context.find(key).has_value() {
            .base!.insert(key, value)
            return
        }

        .map.set(key, value)
    }

    public fn dump(this) {
        for (key, value) in .map {
            eprintln("  {}: {}", key, value)
        }
        if .base is Some(base) { base.dump() }
    }

    public fn mutable_snapshot(this) -> Context<K, V> {
        mut map: [K:V] = [:]
        mut base = .base
        while base is Some(b) {
            for (key, value) in b.map {
                if not map.contains(key) {
                    map.set(key, value)
                }
            }
            base = b.base
        }
        for (key, value) in .map {
            map.set(key, value)
        }
        return Context(map)
    }

    public fn unify(mut this, anon other: Context<K, V>, anon merge: &fn(anon a: V, anon b: V) -> V) throws {
        if other.base is Some(base) {
            .unify(base, merge)
        }

        for (key, value) in other.map {
            if .find(key) is Some(existing) {
                .insert(key, merge(existing, value))
            } else {
                .insert(key, value)
            }
        }
    }

    public fn iterator(this) -> DictionaryIterator<K, V> {
        let context = .mutable_snapshot()
        return context.map.iterator()
    }
}

fn child_context<K requires(Hashable), V>(anon parent: Context<K, V>) -> Context<K, V> {
    return Context(map: [:], base: Some(parent))
}

fn make_type(
    type_map: &mut [TypeId:Type]
    anon type: Type
) -> TypeId {
    let id = TypeId(id: type_map.size() as! u64)
    type_map.set(id, type)
    return id
}

fn merge_bounds(
    type_map: &mut [TypeId: Type]
    epsilon_context: &mut Context<EpsilonId, Epsilon>
    anon type1: Type
    anon type2: Type
    op: Operation
) throws -> Type {
    if type2 is TypeWithSec and not type1 is TypeWithSec { return merge_bounds(type_map, epsilon_context, type2, type1, op) }
    return match type1 {
        Unchecked => type2
        Int(range1) => match type2 {
            Int(range2) => Type::Int(match range1 {
                Unknown => range1
                Bounded(from: from1, to: to1) => match range2 {
                    Unknown => range2
                    Bounded(from: from2, to: to2) => match op {
                        Add => InferredRange::Bounded(from: from1 + from2, to: to1 + to2)
                        Sub => InferredRange::Bounded(from: from1 - to2, to: to1 - from2)
                        Gt => InferredRange::Bounded(from: match from1 > from2 { true => 1, false => 0 }, to: match to1 > to2 { true => 1, false => 0 })
                        Mul => InferredRange::Bounded(
                            from: min(min(from1 * from2, from1 * to2), min(to1 * from2, to1 * to2))
                            to: max(max(from1 * from2, from1 * to2), max(to1 * from2, to1 * to2))
                        )
                        Div => match from2 == 0 or to2 == 0 {
                            true => InferredRange::Unknown
                            false => InferredRange::Bounded(from: min(min(from1 / from2, from1 / to2), min(to1 / from2, to1 / to2)) to: max(max(from1 / from2, from1 / to2), max(to1 / from2, to1 / to2)))
                        }
                        Pair => {
                            eprintln("Invalid operation for int: Pair")
                            abort()
                        }
                    }
                }
            })
            else => {
                eprintln("Type mismatch between {} and {}", type1, type2)
                abort()
            }
        }
        Bool(range1) => match type2 {
            Bool(range2) => Type::Bool(match range1 {
                Unknown => range1
                Bounded(from: from1, to: to1) => match range2 {
                    Unknown => range2
                    Bounded(from: from2, to: to2) => match op {
                        // Add: OR, Mul: AND, Sub: AND NOT, Div: AND NOT; TODO: Split into actual bool operations.
                        Add => InferredRange::Bounded(from: from1 or from2, to: to1 or to2)
                        Mul => InferredRange::Bounded(from: from1 and from2, to: to1 and to2)
                        Sub => InferredRange::Bounded(from: from1 and not to2, to: to1 and not from2)
                        Div => InferredRange::Bounded(from: from1 and not to2, to: to1 and not from2)
                        Gt => {
                            eprintln("Invalid operation for bool: Gt")
                            abort()
                        }
                        Pair => {
                            eprintln("Invalid operation for int: Pair")
                            abort()
                        }
                    }
                }
            })
            else => {
                eprintln("Type mismatch between {} and {}", type1, type2)
                return type1
            }
        }
        Pair(left, right) => match type2 {
            Pair(left: left2, right: right2) => {
                let left_type = type_map[left]
                let right_type = type_map[right]
                let new_left = merge_bounds(type_map, epsilon_context, left_type, type_map[left2], op)
                let new_right = merge_bounds(type_map, epsilon_context, right_type, type_map[right2], op)
                yield Type::Pair(left: make_type(type_map, new_left), right: make_type(type_map, new_right))
            }
            TypeWithSec => merge_bounds(type_map, epsilon_context, type2, type1, op)
            else => {
                eprintln("Type mismatch between {} and {}", type1, type2)
                abort()
            }
        }
        List => {
            eprintln("TODO: Implement list type merging")
            return type1
        }
        TypeWithSec(type: ty1, label: label1, epsilon: epsilon1) => match type2 {
            TypeWithSec(type: ty2, label: label2, epsilon: epsilon2) => {
                if label1 != label2 {
                    eprintln("Label mismatch between {} and {}", type1.render(&type_map), type2.render(&type_map))
                    return type2
                }
                let inner = merge_bounds(type_map, epsilon_context, type_map[ty1], type_map[ty2], op)
                let epsilon = EpsilonId(id: epsilon_context.map.size() as! u64)
                epsilon_context.insert(epsilon, Epsilon::Max(a: epsilon1, b: epsilon2))
                yield Type::TypeWithSec(type: make_type(type_map, inner), label: label1, epsilon)
            }
            else => {
                let inner = merge_bounds(type_map, epsilon_context, type_map[ty1], type2, op)
                yield Type::TypeWithSec(type: make_type(type_map, inner), label: label1, epsilon: epsilon1)
            }
        }
    }
}

fn smooth(anon existing: f64, anon local: f64, beta: f64) -> f64 {
    let result = existing * exp(-beta * local)
    print("Smoothed {} with {} and {} to {}\n", existing, local, beta, result)
    return result
}

fn max_difference_for(anon x: &Type, anon type_map: &[TypeId: Type]) -> f64? => match x {
    Int(range) => match range {
        Unknown => None // TODO: Implement infinite sensitivity
        Bounded(from, to) => fabs(to as! f64 - from as! f64)
    }
    Bool => 1f64
    List(type) | TypeWithSec(type) => max_difference_for(&type_map[type], type_map)
    Pair(left, right) => {
        if max_difference_for(&type_map[left], type_map) is Some(left_diff)
            and max_difference_for(&type_map[right], type_map) is Some(right_diff) {
            return max(left_diff, right_diff)
        }
        return None
    }
    else => None
}

fn sens_merge(
    anon sens1: SensitivityId?
    anon sens2: SensitivityId?
    op: Operation
    local_sensitivity: f64
    sensitivity_context: &mut Context<SensitivityId, f64>
    type_map: &mut [TypeId: Type]
    anon lhs: Type
    anon rhs: Type
) -> SensitivityId? {
    if sens1 is None { return sens2 }
    if sens2 is None { return sens1 }

    let s1 = sens1!
    let s2 = sens2!

    let value1 = sensitivity_context.lookup(s1)
    let value2 = sensitivity_context.lookup(s2)

    guard max_difference_for(&lhs, &type_map) is Some(lhs_max_diff)
        and max_difference_for(&rhs, &type_map) is Some(rhs_max_diff)
        else { return None }
    let result = match op {
        Add | Sub => value1 + value2 + local_sensitivity
        Mul | Div => value1 * rhs_max_diff + value2 * lhs_max_diff + local_sensitivity
        Gt => 1f64
        Pair => 1f64
    }

    let id = SensitivityId(id: sensitivity_context.map.size() as! u64)
    sensitivity_context.map.set(id, result)
    return id
}

fn typecheck(
    lattice: &LabelLattice
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, Epsilon>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon mut expr: Expression
) throws -> Expression {
    let retv = fn[
        &lattice, &mut type_map, &mut type_context, &mut type_level_sensitivity_context, &mut epsilon_context, &mut sensitivity_context, &mut expr
    ]() throws => match expr {
        IntLiteral(value) => expr.with_type(make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: value, to: value))))
        ListLiteral(elements) => {
            mut element_type: TypeId? = None
            mut checked_elements: [Expression] = []
            for element in elements {
                let checked_element = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, element)
                checked_elements.push(checked_element)
                if element_type is None {
                    element_type = checked_element.type.value
                } else {
                    element_type = make_type(&mut type_map, merge_bounds(type_map, epsilon_context, type_map[element_type!], type_map[checked_element.type.value], op: Operation::Add))
                }
            }
            if element_type is None {
                eprintln("Could not determine element type for list, defaulting to unchecked")
                element_type = make_type(&mut type_map, Type::Unchecked)
            }

            let type = make_type(type_map, Type::List(type: element_type!, size: elements.size()))
            yield Expression::ListLiteral(elements: checked_elements).with_type(type)
        }
        Variable(name) => {
            let type = type_context.lookup(name)
            yield expr.with_type(
                type
                sensitivity: type_level_sensitivity_context.find(type)
            ).add_sensitivity(sensitivity_context)
        }
        Subscript(expr, index) => {
            let checked_expr = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, expr)
            let checked_index = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, index)
            mut expr_type = type_map[checked_expr.type.value]
            let unchecked_expr = Expression::Subscript(expr: checked_expr, index: checked_index)
            mut wrap_with_sec = fn(anon type: TypeId) throws => type

            if expr_type is TypeWithSec(type, label, epsilon) {
                wrap_with_sec = fn[
                    &mut type_map
                    label
                    epsilon
                ](anon type: TypeId) throws -> TypeId => make_type(type_map, Type::TypeWithSec(type, label, epsilon))
                expr_type = type_map[type]
            }

            mut result = match expr_type {
                List(type, size) => unchecked_expr.with_type(wrap_with_sec(type))
                Pair(left, right) => match checked_index {
                    IntLiteral(value) => match value {
                        0 => unchecked_expr.with_type(wrap_with_sec(left))
                        1 => unchecked_expr.with_type(wrap_with_sec(right))
                        else => {
                            eprintln("Invalid index for pair: {}", value)
                            abort()
                        }
                    }
                    else => {
                        eprintln("Invalid index type for pair: {}", checked_index)
                        abort()
                    }
                }
                else => {
                    eprintln("Invalid subscript type: {}", expr_type)
                    eprintln("  on expression: {}", checked_expr.to_lang(&type_map))
                    abort()
                }
            }

            yield result.add_sensitivity(sensitivity_context)
        }
        Declassify(expr, source_epsilon, target_label, target_epsilon) => {
            let checked_expr = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, expr)
            let label = target_label
            guard lattice.best_path_for(
                from: type_map[checked_expr.type.value].label(lattice)
                to: label
                epsilon: epsilon_context.lookup(target_epsilon)
            ) is Some(pc) else {
                eprintln("Going from {} to {} is either not a declassify, or is not possible", type_map[checked_expr.type.value].label(lattice), label)
                return checked_expr
            }

            let (path, cost) = pc

            eprintln("Path from {} to {}: {} (cost = {})", type_map[checked_expr.type.value].label(lattice), label, path, cost)
            let type = make_type(type_map, Type::TypeWithSec(type: checked_expr.type.value, label, epsilon: target_epsilon))
            let used_eps_id = EpsilonId(id: epsilon_context.map.size() as! u64)
            let used_eps_multiplier_id = EpsilonId(id: (epsilon_context.map.size() + 1) as! u64)
            epsilon_context.insert(used_eps_id, Epsilon::Multiply(a: source_epsilon, b: used_eps_multiplier_id))
            epsilon_context.insert(used_eps_multiplier_id, Epsilon::Fixed(cost))
            eprintln("Will use eps {} ({} * {})", used_eps_id, source_epsilon, used_eps_multiplier_id)
            

            yield Expression::Declassify(
                expr: checked_expr
                source_epsilon
                target_label: label
                target_epsilon
                used_epsilon: used_eps_id
            ).with_type(
                type
                sensitivity: checked_expr.type.sensitivity
                sensitivity_multiplier: checked_expr.type.sensitivity_multiplier
            )
        }
        Noise(expr, epsilon) => {
            let checked_expr = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, expr)
            // {\frac
            //     {\begin{array}{ccc}%
            //         L : \ell \quad
            //         \sensitivityContext, \epsilonContext, \Gamma \vdash x \hasTypeWithSens{\symbolic{s}} \tau^L_{\epsilon_1} \quad
            //         \epsilon_2 \leq \epsilon_1 \\
            //         \Gamma^\prime = \Gamma[x \mapsto \tau^L_{\epsilon_1 - \epsilon_2}] \quad
            //         \epsilonContext^\prime = \epsilonContext[\epsilon_1 \mapsto \epsilon_1 - \epsilon_2]
            //     \end{array}}
            //     {\epsilonContext, \Gamma \vdash \mathsf{noise}(x, \epsilon_2) \hasTypeWithSens{\symbolic{s}} \tau^L_{\epsilon_2} \quad
            //     \epsilonContext^\prime, \Gamma^\prime \vdash x \hasTypeWithSens{\symbolic{s}} \tau^L_{\epsilon_1}}}^\mathcomment{Noise}
            let expr_type = type_map[checked_expr.type.value]
            let epsilon2 = type_map[checked_expr.type.value].epsilon(&type_map)
            let new_epsilon = EpsilonId(id: epsilon_context.map.size() as! u64)
            epsilon_context.insert(new_epsilon, Epsilon::Subtract(a: epsilon, b: epsilon2))
            let new_type = make_type(type_map, Type::TypeWithSec(type: checked_expr.type.value, label: expr_type.label(lattice), epsilon: new_epsilon))
            yield Expression::Noise(expr: checked_expr, epsilon).with_type(
                new_type
                sensitivity: checked_expr.type.sensitivity
                sensitivity_multiplier: checked_expr.type.sensitivity_multiplier
            )
        }
        Operation(op, operands) => {
            let checked_operands = operands.map(
                &fn[
                    &lattice
                    &mut type_map
                    &mut type_context
                    &mut type_level_sensitivity_context
                    &mut epsilon_context
                    &mut sensitivity_context
                ](anon x: &Expression) throws -> (Expression, Context<SensitivityId, f64>) {
                    mut new_sensitivity_context = child_context(*sensitivity_context)
                    let result = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context: &mut new_sensitivity_context, *x)
                    return (result, new_sensitivity_context)
                }
            )
            let type = match op {
                Pair => {
                    if checked_operands.size() != 2 {
                        eprintln("Pair operation requires exactly 2 operands")
                        abort()
                    }

                    let left = checked_operands[0].0.type.value
                    let right = checked_operands[1].0.type.value
                    let left_sens = checked_operands[0].0.type.sensitivity
                    let right_sens = checked_operands[1].0.type.sensitivity
                    let sens = sens_merge(
                        left_sens
                        right_sens
                        op
                        local_sensitivity: 0f64
                        sensitivity_context
                        type_map
                        type_map[left]
                        type_map[right]
                    )
                    let type = make_type(type_map, Type::Pair(left, right))
                    yield SensitivityMapped(value: type, sensitivity: sens)
                }
                else => fold(
                    checked_operands.map(
                        &fn(
                            anon x: &(Expression, Context<SensitivityId, f64>)
                        ) throws -> (SensitivityMapped<TypeId>, Context<SensitivityId, f64>) => (x.0.type, x.1)
                    ),
                    &fn[
                        &mut type_map
                        &mut type_context
                        &mut epsilon_context
                        &mut sensitivity_context
                        op
                    ](
                        anon acc: (SensitivityMapped<TypeId>, Context<SensitivityId, f64>)
                        anon x: &(SensitivityMapped<TypeId>, Context<SensitivityId, f64>)
                    ) throws -> (SensitivityMapped<TypeId>, Context<SensitivityId, f64>) {
                        let acc_type = type_map[acc.0.value]
                        let x_type = type_map[x.0.value]
                        // FIXME: Implement type unification + sensitivity merging
                        let local_sensitivity = match x.0.sensitivity.has_value() {
                            true => x.1.lookup(x.0.sensitivity!)
                            false => 0f64
                        }
                        let sensitivity = sens_merge(
                            acc.0.sensitivity
                            x.0.sensitivity
                            op
                            local_sensitivity
                            &mut sensitivity_context
                            &mut type_map
                            acc_type
                            x_type
                        )
                        let sens = SensitivityMapped(
                            value: make_type(type_map, merge_bounds(type_map, epsilon_context, acc_type, x_type, op))
                            sensitivity
                        )
                        return (sens, acc.1)
                    }
                ).0
            }

            yield Expression::Operation(type, op, operands: checked_operands.map(&fn(anon x: &(Expression, Context<SensitivityId, f64>)) throws => x.0))
        }
        Call(procedure, arguments) => {
            mut checked_arguments: [(Expression, Context<SensitivityId, f64>)] = []
            for argument in arguments {
                mut new_sensitivity_context = child_context(*sensitivity_context)
                let result = typecheck(
                    lattice
                    type_map
                    type_context
                    type_level_sensitivity_context
                    epsilon_context
                    sensitivity_context: &mut new_sensitivity_context
                    argument
                )
                checked_arguments.push((result, new_sensitivity_context))
            }

            mut new_type_context = child_context(*type_context)
            for (name, type) in procedure.parameters {
                new_type_context.insert(name, type.value)
            }
            let checked_procedure = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, procedure)
            let return_type = type_map[checked_procedure.return_type]
            let return_sens = type_level_sensitivity_context.find(checked_procedure.return_type)
            let type = make_type(type_map, return_type)
            if return_sens is Some(value) {
                type_level_sensitivity_context.insert(type, value)
            }

            mut operands: [Expression] = []
            for (argument, _) in checked_arguments {
                operands.push(argument)
            }

            yield Expression::Call(procedure: checked_procedure, arguments: operands).with_type(
                type
                sensitivity: return_sens
            )
        }
        ForEach(var, index, accum, accum_init, list, body) => {
            let list_expr = typecheck(
                lattice
                type_map
                type_context
                type_level_sensitivity_context
                epsilon_context
                sensitivity_context
                list
            )
            let list_type = type_map.get(list_expr.type.value)!
            let list_sens = type_level_sensitivity_context.find(list_expr.type.value)
            let accum_init_expr = typecheck(
                lattice
                type_map
                type_context
                type_level_sensitivity_context
                epsilon_context
                sensitivity_context
                accum_init
            )
            mut new_type_sensitivity_context = child_context(*type_level_sensitivity_context)

            let accum_var_type = accum_init_expr.type.value
            let entry_var_type = list_type.element_type(&mut type_map)
            mut new_type_context = child_context(*type_context)
            new_type_context.insert(var, match type_map[entry_var_type] {
                TypeWithSec(type, label, epsilon) => {
                    let div_eps = EpsilonId(id: epsilon_context.map.size() as! u64)
                    epsilon_context.insert(div_eps, Epsilon::Fixed(1f64 / list_type.element_count(&type_map) as! f64))
                    let split_eps = EpsilonId(id: epsilon_context.map.size() as! u64)
                    epsilon_context.insert(split_eps, Epsilon::Multiply(a: epsilon, b: div_eps))
                    yield make_type(
                        &mut type_map
                        Type::TypeWithSec(type, label, epsilon: split_eps)
                    )
                }
                else => entry_var_type
            })
            let entry_var_sens = SensitivityId(id: sensitivity_context.map.size() as! u64)
            sensitivity_context.insert(entry_var_sens, 1f64)
            new_type_sensitivity_context.map.set(entry_var_type, entry_var_sens)
            let index_var_type = make_type(
                &mut type_map
                Type::Int(InferredRange::Bounded(from: 0i64, to: list_type.element_count(&type_map) as! i64 - 1i64))
            )
            new_type_context.insert(index, index_var_type)
            let index_var_sens = SensitivityId(id: sensitivity_context.map.size() as! u64)
            sensitivity_context.insert(index_var_sens, 1f64)
            new_type_sensitivity_context.map.set(index_var_type, index_var_sens)
            new_type_context.insert(accum, accum_var_type)
            let accum_var_sens = SensitivityId(id: sensitivity_context.map.size() as! u64)
            sensitivity_context.insert(accum_var_sens, 1f64)
            new_type_sensitivity_context.map.set(accum_var_type, accum_var_sens)

            if sens_merge(
                    list_sens
                    entry_var_sens
                    op: Operation::Add
                    local_sensitivity: 0f64
                    sensitivity_context
                    type_map
                    list_type
                    type_map.get(entry_var_type)!
                ) is Some(new_sens) {
                new_type_sensitivity_context.insert(entry_var_type, new_sens)
                sensitivity_context.insert(new_sens, 1f64)
            }

            let body_stmt = typecheck(
                lattice
                type_map
                type_context: &mut new_type_context
                type_level_sensitivity_context: &mut new_type_sensitivity_context
                epsilon_context
                sensitivity_context
                body
            )
            let body_sens = body_stmt.type.sensitivity
            mut loop_sensitivity = body_stmt.type.sensitivity
            mut loop_sensitivity_multiplier = list_type.element_count(&type_map) as! f64

            if sens_merge(
                list_sens
                body_sens
                op: Operation::Add
                local_sensitivity: 0f64
                sensitivity_context
                type_map
                type_map.get(list_expr.type.value)!
                type_map.get(body_stmt.type.value)!
            ) is Some(new_sens) {
                type_level_sensitivity_context.insert(body_stmt.type.value, new_sens)
                let total_sensitivity_multiplier = list_type.element_count(&type_map)
                loop_sensitivity = new_sens
                loop_sensitivity_multiplier = total_sensitivity_multiplier as! f64
            }

            yield Expression::ForEach(var, index, accum, accum_init: accum_init_expr, list: list_expr, body: body_stmt).with_type(
                type: accum_var_type
                sensitivity: loop_sensitivity
                sensitivity_multiplier: loop_sensitivity_multiplier
            )
        }
        IfThenElse(condition, consequence, alternative) => {
            let checked_condition = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, condition)
            let checked_consequence = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, consequence)
            let checked_alternative = typecheck(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, alternative)
            eprintln("IfThenElse: {} {} {}", checked_condition.to_tree(&type_map), checked_consequence.to_tree(&type_map), checked_alternative.to_tree(&type_map))

            let consequence_type = type_map[checked_consequence.type.value]
            let alternative_type = type_map[checked_alternative.type.value]
            let new_type = make_type(type_map, merge_bounds(type_map, epsilon_context, consequence_type, alternative_type, op: Operation::Add))
            let new_sens = sens_merge(
                type_level_sensitivity_context.find(checked_consequence.type.value)
                type_level_sensitivity_context.find(checked_alternative.type.value)
                op: Operation::Add
                local_sensitivity: 0f64
                sensitivity_context
                type_map
                consequence_type
                alternative_type
            )
            let new_sens_multiplier = match new_sens.has_value() {
                true => {
                    type_level_sensitivity_context.insert(new_type, new_sens!)
                    yield sensitivity_context.lookup(new_sens!)
                }
                false => 1f64
            }
            yield Expression::IfThenElse(condition: checked_condition, consequence: checked_consequence, alternative: checked_alternative).with_type(
                type: new_type
                sensitivity: new_sens
                sensitivity_multiplier: new_sens_multiplier
            )
        }
        Let(var, value, body) => {
            let checked_value = typecheck(
                lattice
                type_map
                type_context
                type_level_sensitivity_context
                epsilon_context
                sensitivity_context
                value
            )
            let maybe_var_type = type_context.find(var)
            yield match maybe_var_type.has_value() {
                true => {
                    let var_type = maybe_var_type!
                    let value_type = type_map.get(checked_value.type.value)!
                    let new_type = merge_bounds(type_map, epsilon_context, type_map[var_type], value_type, op: Operation::Add)
                    let new_sens = sens_merge(
                        type_level_sensitivity_context.find(var_type)
                        checked_value.type.sensitivity
                        op: Operation::Add
                        local_sensitivity: 0f64
                        sensitivity_context
                        type_map
                        type_map[var_type]
                        value_type
                    )
                    let type = make_type(type_map, new_type)
                    let new_sens_multiplier = match new_sens.has_value() {
                        true => {
                            type_level_sensitivity_context.insert(type, new_sens!)
                            eprintln(" -- Letting {} with sens {}", var, new_sens!)
                            yield sensitivity_context.lookup(new_sens!)
                        }
                        false => 1f64
                    }
                    let checked_body = typecheck(
                        lattice
                        type_map
                        type_context
                        type_level_sensitivity_context
                        epsilon_context
                        sensitivity_context
                        body
                    )
                    
                    yield Expression::Let(var, value: checked_value, body: checked_body).with_type(
                        type: checked_body.type.value
                        sensitivity: new_sens
                        sensitivity_multiplier: new_sens_multiplier
                    )
                }
                false => {
                    let new_type = make_type(type_map, type_map[checked_value.type.value])
                    type_context.insert(var, new_type)
                    let checked_body = typecheck(
                        lattice
                        type_map
                        type_context
                        type_level_sensitivity_context
                        epsilon_context
                        sensitivity_context
                        body
                    )

                    yield Expression::Let(var, value: checked_value, body: checked_body).with_type(
                        type: checked_body.type.value
                        sensitivity: checked_value.type.sensitivity
                        sensitivity_multiplier: checked_value.type.sensitivity_multiplier
                    )
                }
            }
        }
        Ignore => expr
    }

    let result = retv()
    return result
}

fn typecheck(
    lattice: &LabelLattice
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, Epsilon>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon mut proc: Procedure
) throws -> Procedure {
    mut new_type_context = child_context(*type_context)
    mut new_sensitivity_contexts: [Context<SensitivityId, f64>] = []
    for (name, type) in proc.parameters {
        new_type_context.insert(name, type.value)
        new_sensitivity_contexts.push(sensitivity_context.mutable_snapshot())
    }
    mut i = 0uz
    for (name, type) in proc.parameters {
        mut new_type_level_sensitivity_context = child_context(*type_level_sensitivity_context)
        mut new_epsilon_context = epsilon_context.mutable_snapshot()
        mut new_type_context_snapshot = new_type_context.mutable_snapshot()

        let checked_body = typecheck(
            lattice
            type_map
            type_context: &mut new_type_context_snapshot
            type_level_sensitivity_context: &mut new_type_level_sensitivity_context
            epsilon_context: &mut new_epsilon_context
            sensitivity_context: &mut new_sensitivity_contexts[i]
            proc.body
        )
        i += 1
    }

    for context in new_sensitivity_contexts {
        sensitivity_context.unify(context, &fn(anon a: f64, anon b: f64) -> f64 => a + b)
    }

    let checked_body = typecheck(
        lattice
        type_map
        type_context: &mut new_type_context
        type_level_sensitivity_context
        epsilon_context
        sensitivity_context
        proc.body
    )

    mut return_type = type_map.get(checked_body.type.value)!
    proc.return_type = match return_type {
        Unchecked => proc.return_type
        else => {
            proc.body = checked_body
            yield make_type(type_map, return_type)
        }
    }
    mut return_sens = type_level_sensitivity_context.find(checked_body.type.value)

    // If the sensitivity of the body * input epsilon is greater than the sensitivity of the return type, it's impossible to return the value.
    // So reject the program.
    let body_sens = checked_body.type.sensitivity
    let body_sens_multiplier = checked_body.type.sensitivity_multiplier

    return_sens = return_sens ?? body_sens

    if (
        body_sens.has_value() and return_sens.has_value()
        ) and sensitivity_context.lookup(body_sens!) * body_sens_multiplier > sensitivity_context.lookup(return_sens!) {
        eprintln(
            "Body sensitivity {} * {} > Return sensitivity {}"
            sensitivity_context.lookup(body_sens!)
            body_sens_multiplier
            sensitivity_context.lookup(return_sens!)
        )
        eprintln("Body: {}", checked_body.to_tree(&type_map))
    }

    if return_sens is Some(value) {
        type_level_sensitivity_context.insert(proc.return_type, value)
    }

    return proc
}

fn main(args: [String]) {
    mut type_map: [TypeId:Type] = [unchecked(): Type::Unchecked]
    mut type_context: Context<String, TypeId> = Context(map: [:])
    mut type_level_sensitivity_context: Context<TypeId, SensitivityId> = Context(map: [:])
    mut epsilon_context: Context<EpsilonId, Epsilon> = Context(map: [:])
    mut sensitivity_context: Context<SensitivityId, f64> = Context(map: [:])
    let scale = 499
    let map_direct = fn[scale](anon from: Label, anon to: Label, anon available_epsilon: Epsilon) -> f64 => scale as! f64 // todo!
    mut lattice = LabelLattice::make(
        hierarchy: [
            "Public": []
            "L1": ["Public"]
            "L2": ["L1"]
            "L3": ["Public"]
        ] as! [Label:[Label]]
        epsilon_map: [
            "Public": Epsilon::Fixed(0f64)
            "L1": Epsilon::RuntimeVar(name: "e1")
            "L2": Epsilon::RuntimeVar(name: "e2")
            "L3": Epsilon::RuntimeVar(name: "e3")
        ] as! [Label:Epsilon]
        &map_direct
    )
    
    let test_name = args[1..].first() ?? "wavg"

    let procs = make_test_program(
        &lattice
        &mut type_map
        &mut type_context
        &mut type_level_sensitivity_context
        &mut epsilon_context
        &mut sensitivity_context
        match test_name {
            "wavg" => Sample::Wavg
            "noisymax" => Sample::NoisyMax
            else => {
                eprintln("Unknown test: {}", test_name)
                eprintln("Available tests: wavg, noisymax")
                return 1
            }
        }
        0..scale
    )

    mut checked_procs: [Procedure] = []
    for proc in procs {
        let checked = typecheck(
            &lattice
            &mut type_map
            &mut type_context
            &mut type_level_sensitivity_context
            &mut epsilon_context
            &mut sensitivity_context
            proc
        )
        checked_procs.push(checked)
    }

    for proc in checked_procs {
        eprintln("{}", proc.to_lang(&type_map, indent: 0))
    }
    eprintln("main()")

    eprintln("{}", lattice.render())

    eprintln("Sensitivity context:")
    sensitivity_context.dump()
    eprintln("Epsilon context:")
    epsilon_context.dump()

    for proc in checked_procs {
        eprintln("{}", proc.to_tree(&type_map, indent: 0))
    }

    codegen(
        &lattice
        &mut type_map
        &mut type_context
        &mut type_level_sensitivity_context
        &mut epsilon_context
        &mut sensitivity_context
        checked_procs
    )
}

fn codegen(
    lattice: &LabelLattice
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, Epsilon>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon proc: Procedure
) throws {
    codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, proc.return_type)
    print(" {}(", proc.name)
    mut first = true
    for (name, type) in proc.parameters {
        if not first {
            print(", ")
        }
        codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, type.value)
        print(" {}", name)
        first = false
    }
    print(") {{\n")
    print("return (")
    codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, proc.body)
    print(");\n")
    print("}}\n")
}

fn codegen(
    lattice: &LabelLattice
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, Epsilon>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon procs: [Procedure]
) throws {

    println("#include <array>")
    println("#include <utility>")
    println("#include <variant>")
    println("#include <string>")
    println("#include <random>")
    println("#include <cmath>")
    println("#include <iostream>")
    
    println("using namespace std;")
    println()

    // e*(...)
    println("using Epsilon = variant<double, string>;")
    println("Epsilon emul(Epsilon a, Epsilon b) {{")
    println("    if (a.index() == 0 && b.index() == 0) {{")
    println("        return get<double>(a) * get<double>(b);")
    println("    }} else {{")
    println("        cerr << \"Runtime epsilon variable\" << endl;")
    println("        abort();")
    println("    }}")
    println("}}")

    println("Epsilon esub(Epsilon a, Epsilon b) {{")
    println("    if (a.index() == 0 && b.index() == 0) {{")
    println("        return get<double>(a) - get<double>(b);")
    println("    }} else {{")
    println("        cerr << \"Runtime epsilon variable\" << endl;")
    println("        abort();")
    println("    }}")
    println("}}")

    println("Epsilon emax(Epsilon a, Epsilon b) {{")
    println("    if (a.index() == 0 && b.index() == 0) {{")
    println("        return max(get<double>(a), get<double>(b));")
    println("    }} else {{")
    println("        cerr << \"Runtime epsilon variable\" << endl;")
    println("        abort();")
    println("    }}")
    println("}}")

    println("Epsilon emin(Epsilon a, Epsilon b) {{")
    println("    if (a.index() == 0 && b.index() == 0) {{")
    println("        return min(get<double>(a), get<double>(b));")
    println("    }} else {{")
    println("        cerr << \"Runtime epsilon variable: \" << endl;")
    println("        abort();")
    println("    }}")
    println("}}")

    println("Epsilon evar(string name) {{")
    println("    return 50.0;")
    println("}}")
    println()

    mut epsilon_context_copy = epsilon_context.mutable_snapshot()
    lattice.all_paths(epsilon_context: &mut epsilon_context_copy)

    // Dump Epsilons:
    for (id, _) in epsilon_context_copy {
        println("extern Epsilon E{};", id.id)
    }

    // Labels:
    println("enum Label {{")
    for label in lattice.all_labels() {
        println("    {},", label.name)
    }
    println("}};")

    println("struct LabelPath {{")
    println("    Label from;")
    println("    Label to;")
    println("    Epsilon epsilon;")
    println("}};")

    let paths = lattice.all_paths(&mut epsilon_context)
    for (from, to, epsilon) in paths {
        println("LabelPath path_{}_{} {{", from.name, to.name)
        println("    {},", from.name)
        println("    {},", to.name)
        println("    E{},", epsilon.id)
        println("}};")
    }

    println("auto paths = array<LabelPath*, {}>{{", paths.size())
    for (from, to, _) in paths {
        println("    &path_{}_{},", from.name, to.name)
    }
    println("}};")

    for (id, epsilon) in epsilon_context {
        print("Epsilon E{} = ", id.id)
        match epsilon {
            Fixed(value) => print("{:.5f}", value)
            Multiply(a, b) => print("emul(E{}, E{})", a.id, b.id)
            Subtract(a, b) => print("esub(E{}, E{})", a.id, b.id)
            Max(a, b) => print("emax(E{}, E{})", a.id, b.id)
            Min(a, b) => print("emin(E{}, E{})", a.id, b.id)
            RuntimeVar(name) => print("evar(\"{}\")", name)
        }
        println(";")
    }

    // noise(x, e) = laplace(x, e)
    println("template<typename T>")
    println("T noise(T x, Epsilon epsilon) {{")
    println("#ifdef NO_NOISE")
    println("    return x;")
    println("#else")
    println("    if (epsilon.index() == 0) {{")
    println("        double e = get<double>(epsilon);")
    println("        random_device rd;")
    println("        mt19937 gen(rd());")
    println("        uniform_real_distribution<double> dist(0.0, 1.0);")
    println("        double u = dist(gen);")
    println("        if (u < 0.5) {{")
    println("            return x + e * log(2 * u);")
    println("        }} else {{")
    println("            return x - e * log(2 * (1 - u));")
    println("        }}")
    println("    }} else {{")
    println("        string name = get<string>(epsilon);")
    println("        cerr << \"Runtime epsilon variable: \" << name << endl;")
    println("        abort();")
    println("    }}")
    println("#endif")
    println("}}")

    // declassify(...)
    println("template<typename T>")
    println("T declassify(T x, Label source_label, Epsilon source, Label target_label, Epsilon target) {{")
    println("     for (auto path : paths) {{")
    println("         if (path->from == source_label && path->to == target_label) {{")
    println("             return noise(x, esub(target, path->epsilon));")
    println("         }}")
    println("     }}")
    println("     abort();")
    println("}}")

    for proc in procs {
        codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, proc)
    }
}

fn codegen(
    lattice: &LabelLattice
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, Epsilon>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon expr: Expression
) throws {
    match expr {
        IntLiteral(value) => print("{}", value)
        ListLiteral(type, elements) => {
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, type.value)
            print("{{")
            mut first = true
            for element in elements {
                if not first {
                    print(", ")
                }
                codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, element)
                first = false
            }
            print("}}")
        }
        Variable(name) => print("{}", name)
        Subscript(expr, index) => {
            if type_map[expr.type.value].pure_type(&type_map) is Pair {
                // get<index>(expr)
                print("get<")
                codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, index)
                print(">(")
                codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, expr)
                print(")")
            } else {
                // List or something
                codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, expr)
                print("[")
                codegen(
                    lattice
                    type_map
                    type_context
                    type_level_sensitivity_context
                    epsilon_context
                    sensitivity_context
                    index
                )
                print("]")
            }
        }
        Declassify(expr, source_epsilon, target_label, target_epsilon) => {
            print("declassify(")
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, expr)
            print(
                ", {}, E{}, {}, E{})"
                type_map[expr.type.value].label(lattice).name
                source_epsilon.id
                target_label.name
                target_epsilon.id
            )
        }
        Noise(expr, epsilon) => {
            print("noise(")
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, expr)
            print(", E{})", epsilon.id)
        }
        Operation(op, operands) => match op {
            Pair => {
                print("std::make_pair(")
                mut first = true
                for operand in operands {
                    if not first {
                        print(", ")
                    }
                    codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, operand)
                    first = false
                }
                print(")")
            }
            else => {
                let op_str = match op {
                    Add => "+"
                    Sub => "-"
                    Mul => "*"
                    Div => "/"
                    Gt => ">"
                    Pair => { abort() }
                }
                mut first = true
                for operand in operands {
                    if not first {
                        print(" {} ", op_str)
                    }
                    codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, operand)
                    first = false
                }
            }
        }
        Call(procedure, arguments) => {
            print("{}(", procedure.name)
            mut first = true
            for argument in arguments {
                if not first {
                    print(", ")
                }
                codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, argument)
                first = false
            }
            print(")")
        }
        ForEach(var, index, accum, accum_init, list, body) => {
            print("({{\n")
            // type accum = init;
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, accum_init.type.value)
            print(" {} = ", accum)
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, accum_init)
            print(";\n")

            // for (type index = 0; index < list.size; index++) {
            let list_type = type_map[list.type.value]
            print("for (int ")
            print("{} = 0; {} < {}; {}++) {{\n", index, index, list_type.element_count(&type_map), index)
            // type var = list[index];
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, list_type.element_type(type_map))
            print(" {} = (", var)
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, list)
            print(")[{}];\n", index)

            // accum = body;
            print("{} = ", accum)
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, body)
            print(";\n")
            print("}}\n")

            print("{}; }})", accum)
        }
        IfThenElse(condition, consequence, alternative) => {
            print("(")
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, condition)
            print(") ? (\n")
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, consequence)
            print(") : (\n")
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, alternative)
            print(")")
        }
        Let(var, value, body) => {
            print("({{\n")
            print("auto {} = ", var)
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, value)
            print(";\n")
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, body)
            print(";\n")
            print("}})")
        }
        Ignore => {}
    }
}

fn codegen(
    lattice: &LabelLattice
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, Epsilon>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon type: TypeId
) throws {
    codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, type_map[type])
}

fn codegen(
    lattice: &LabelLattice
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, Epsilon>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon type: Type
) throws {
    match type {
        Int(range) => print("int")
        List(type, size) => {
            print("array<")
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, type)
            print(", {}>", size)
        }
        Pair(left, right) => {
            print("pair<")
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, left)
            print(", ")
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, right)
            print(">")
        }
        TypeWithSec(type, label, epsilon) => {
            codegen(lattice, type_map, type_context, type_level_sensitivity_context, epsilon_context, sensitivity_context, type)
        }
        Unchecked => {
            eprintln("Unchecked type in codegen")
            abort()
        }
        Bool => print("int")
    }
}

/// Program:
/// ```
/// proc zip (
///   xs : list T n lab { L1 } eps { e1 },
///   ys : list U n lab { L2 } eps { e2 },
/// ) -> list (T lab { L1 } eps { e1 } × U lab { L2 } eps { e2 }) n {...}
///
/// proc wavg (
///   xs : list int n lab { L1 } eps { e1 },
///   ys : list int n lab { L2 } eps { e2 },
/// ) -> int lab { L2 } eps {0} {
///   x = foreach v index i accum x = 0 in zip(xs, ys) {
///     x + declassify (
///       // spend e1 /n declassifying xs[i]
///       v[0] , e1 / n,
///       // to level L2 with target budget e2 /n
///       L2 , e2 / n,
///     ) * v[1]
///   };
///   res = x / n;
///   // Spend e2/n and add noise to result
///   return noise(res, 0)
/// }
/// ```

fn new_sensitivity(
    anon value: f64
    anon sensitivity_context: &mut Context<SensitivityId, f64>
) throws -> SensitivityId {
    let id = SensitivityId(id: sensitivity_context.map.size() as! u64)
    sensitivity_context.insert(id, value)
    return id
}

enum Sample {
    Wavg
    NoisyMax
    CountGtV // V = 42, arbitrary
}

fn make_test_program(
    lattice: &LabelLattice
    type_map: &mut [TypeId:Type]
    type_context: &mut Context<String, TypeId>
    type_level_sensitivity_context: &mut Context<TypeId, SensitivityId>
    epsilon_context: &mut Context<EpsilonId, Epsilon>
    sensitivity_context: &mut Context<SensitivityId, f64>
    anon sample: Sample
    anon gen_range: Range<i64>
) throws -> [Procedure] => match sample {
    Wavg => {
        let list_sens = new_sensitivity(1f64, sensitivity_context)

        let pair_left = make_type(&mut type_map
            Type::TypeWithSec(
                type: make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: -1000i64, to: 1000i64)))
                label: Label(name: "L3")
                epsilon: EpsilonId(id: 0)
        ))
        let pair_right = make_type(&mut type_map
            Type::TypeWithSec(
                type: make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: -1000i64, to: 1000i64)))
                label: Label(name: "L2")
                epsilon: EpsilonId(id: 1)
        ))
        let pairs = make_type(&mut type_map, Type::Pair(left: pair_left, right: pair_right))

        epsilon_context.insert(EpsilonId(id: 0), Epsilon::Fixed(1f64))
        epsilon_context.insert(EpsilonId(id: 1), Epsilon::Fixed(1f64))

        mut xs: [Expression] = []
        mut ys: [Expression] = []
        mut zip_body_params: [Expression] = []

        for i in gen_range {
            xs.push(Expression::IntLiteral(value: i))
            ys.push(Expression::IntLiteral(value: i % 5))
            // zip(int[2] xs, int[2] ys) -> int[2]
            //     [(xs[0], ys[0]), (xs[1], ys[1])]
            zip_body_params.push(
                Expression::Operation(
                    op: Operation::Pair
                    operands: [
                        Expression::Subscript(
                            expr: Expression::Variable(name: "xs")
                            index: Expression::IntLiteral(value: i)
                        )
                        Expression::Subscript(
                            expr: Expression::Variable(name: "ys")
                            index: Expression::IntLiteral(value: i)
                        )
                    ]
                )
            )
        }

        let xs_type = make_type(&mut type_map, Type::List(type: pair_left, size: xs.size()))
        let ys_type = make_type(&mut type_map, Type::List(type: pair_right, size: ys.size()))
        let pair_ret = make_type(&mut type_map, Type::List(type: pairs, size: xs.size()))

        let xs_sens = new_sensitivity(1f64, sensitivity_context)
        let ys_sens = new_sensitivity(1f64, sensitivity_context)

        let zip = Procedure(
            name: "zip"
            parameters: [
                "xs": SensitivityMapped(value: xs_type, sensitivity: Some(list_sens))
                "ys": SensitivityMapped(value: ys_type, sensitivity: Some(list_sens))
            ]
            return_type: pair_ret
            body: Expression::ListLiteral(
                elements: zip_body_params
            )
        )

        type_level_sensitivity_context.insert(xs_type, list_sens)
        type_level_sensitivity_context.insert(ys_type, list_sens)
        type_level_sensitivity_context.insert(pair_ret, list_sens)

        let noise_epsilon = EpsilonId(id: 2)
        epsilon_context.insert(noise_epsilon, Epsilon::Fixed(0f64))

        let first = Expression::Let(
            var: "z"
            value: Expression::ForEach(
                var: "v"
                index: "i"
                accum: "x"
                accum_init: Expression::IntLiteral(value: 0)
                list: Expression::Call(
                    procedure: zip
                    arguments: [
                        Expression::Variable(name: "xs")
                        Expression::Variable(name: "ys")
                    ]
                )
                body: Expression::Operation(
                    op: Operation::Mul
                    operands: [
                        Expression::Operation(
                            op: Operation::Add
                            operands: [
                                Expression::Variable(name: "x")
                                Expression::Declassify(
                                    expr: Expression::Subscript(
                                        expr: Expression::Variable(name: "v")
                                        index: Expression::IntLiteral(value: 0)
                                    )
                                    source_epsilon: EpsilonId(id: 0)
                                    target_label: Label(name: "L2")
                                    target_epsilon: EpsilonId(id: 1)
                                )
                            ]
                        )
                        Expression::Subscript(
                            expr: Expression::Variable(name: "v")
                            index: Expression::IntLiteral(value: 1)
                        )
                    ]
                )
            )
            body: Expression::Let(
                var: "res"
                value: Expression::Operation(
                    op: Operation::Div
                    operands: [
                        Expression::Variable(name: "z")
                        Expression::IntLiteral(value: 2)
                    ]
                )
                body: Expression::Noise(
                    expr: Expression::Variable(name: "res")
                    epsilon: noise_epsilon
                )
            )
        )    

        let wavg = Procedure(
            name: "wavg"
            parameters: [
                "xs": SensitivityMapped(value: xs_type, sensitivity: Some(xs_sens))
                "ys": SensitivityMapped(value: ys_type, sensitivity: Some(ys_sens))
            ]
            return_type: make_type(&mut type_map, Type::Unchecked)
            body: first
        )

        let main = Procedure(
            name: "main"
            parameters: [:]
            return_type: make_type(&mut type_map, Type::Unchecked)
            body: Expression::Call(
                procedure: wavg
                arguments: [
                    Expression::ListLiteral(
                        elements: xs
                    )
                    Expression::ListLiteral(
                        elements: ys
                    )
                ]
            )
        )
        yield [zip, wavg, main]
    }
    NoisyMax => {
        // let noisymax = proc(xs: list int 5 lab{L1} eps{e1}) -> int lab{L2} eps{e2}
        //     (foreach x in xs index i accum s = (0, 0) in
        //         let score = declassify(x, e1/N, L2, e2/N) in
        //             if score > s.0 (score, x) else s).1
        let list_sens = new_sensitivity(1f64, sensitivity_context)

        mut list_size = 0
        mut test_elements: [Expression] = []
        for i in gen_range {
            list_size += 1
            test_elements.push(Expression::IntLiteral(value: i % 69))
        }

        let e1 = EpsilonId(id: 0)
        let e2 = EpsilonId(id: 1)
        epsilon_context.insert(e1, Epsilon::Fixed(1f64))
        epsilon_context.insert(e2, Epsilon::Fixed(1f64))

        let split_epsilon = EpsilonId(id: epsilon_context.map.size() as! u64)
        epsilon_context.insert(split_epsilon, Epsilon::Fixed(1f64 / list_size as! f64))

        let e1_split_epsilon = EpsilonId(id: epsilon_context.map.size() as! u64)
        epsilon_context.insert(e1_split_epsilon, Epsilon::Multiply(a: e1, b: split_epsilon))

        let e2_split_epsilon = EpsilonId(id: epsilon_context.map.size() as! u64)
        epsilon_context.insert(e2_split_epsilon, Epsilon::Multiply(a: e2, b: split_epsilon))

        let xs_type = make_type(
            &mut type_map
            Type::List(
                type: make_type(
                    &mut type_map
                    Type::TypeWithSec(
                        type: make_type(&mut type_map, type: Type::Int(InferredRange::Bounded(from: 0, to: 69)))
                        label: Label(name: "L1")
                        epsilon: EpsilonId(id: 0)
                    )
                )
                size: list_size as! usize
            )
        )

        let return_type = make_type(
            &mut type_map
            Type::TypeWithSec(
                type: make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: 0, to: 69)))
                label: Label(name: "L2")
                epsilon: EpsilonId(id: 1)
            )
        )

        let xs_sens = new_sensitivity(1f64, sensitivity_context)

        let pair_type = make_type(
            &mut type_map
            Type::Pair(
                left: make_type(&mut type_map, Type::Int(InferredRange::Unknown))
                right: make_type(&mut type_map, Type::Int(InferredRange::Bounded(from: 0i64, to: list_size)))
            )
        )

        let noisymax = Procedure(
            name: "noisymax"
            parameters: [
                "xs": SensitivityMapped(value: xs_type, sensitivity: Some(list_sens))
            ]
            return_type
            body: Expression::Subscript(
                expr: Expression::ForEach(
                    var: "x"
                    index: "i"
                    accum: "s"
                    accum_init: Expression::Operation(
                        op: Operation::Pair
                        operands: [
                            Expression::IntLiteral(value: 0)
                            Expression::IntLiteral(value: 0)
                        ]
                    )
                    list: Expression::Variable(name: "xs")
                    body: Expression::Let(
                        var: "score"
                        value: Expression::Declassify(
                            expr: Expression::Variable(name: "x")
                            source_epsilon: e1_split_epsilon
                            target_label: Label(name: "L2")
                            target_epsilon: e2_split_epsilon
                        )
                        body: Expression::IfThenElse(
                            condition: Expression::Operation(
                                op: Operation::Gt
                                operands: [
                                    Expression::Variable(name: "score")
                                    Expression::Subscript(
                                        expr: Expression::Variable(name: "s")
                                        index: Expression::IntLiteral(value: 0)
                                    )
                                ]
                            )
                            consequence: Expression::Operation(
                                op: Operation::Pair
                                operands: [
                                    Expression::Variable(name: "score")
                                    Expression::Variable(name: "x")
                                ]
                            )
                            alternative: Expression::Variable(name: "s")
                        )
                    )
                )
                index: Expression::IntLiteral(value: 1)
            )
        )

        let main = Procedure(
            name: "main"
            parameters: [:]
            return_type: make_type(&mut type_map, Type::Unchecked)
            body: Expression::Call(
                procedure: noisymax
                arguments: [
                    Expression::ListLiteral(
                        elements: test_elements
                    )
                ]
            )
        )

        yield [noisymax, main]
    }
    CountGtV => {
        // let countgtv = proc(xs: list int 5 lab{L1} eps{e1}) -> int lab{L2} eps{e2}
        //    (foreach x in xs index i accum s = 0 in
        //        let score = declassify(x, e1/N, L2, e2/N) in
        //            if score > 42 s + 1 else s)
        let list_sens = new_sensitivity(1f64, sensitivity_context)
        abort()
    }
}